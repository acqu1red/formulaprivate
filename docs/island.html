<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Остров • MiniApp (ocean border · top view · tuned)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <style>
    :root { --bg:#9ed0ff; --fg:#0c1116; --glass:rgba(255,255,255,.35); --accent:#36c2b6; }
    * { box-sizing: border-box }
    html, body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg); overflow:hidden }
    #app { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }
    #hud { position: fixed; top:10px; left: 50%; transform: translateX(-50%); display:flex; align-items:center; gap:10px; z-index:10; pointer-events:none; }
    .tag { pointer-events:auto; background: rgba(255,255,255,.55); border:1px solid var(--glass); color:#0b1220; padding:6px 10px; border-radius:12px; font-weight:700; backdrop-filter: blur(6px); box-shadow: 0 4px 18px rgba(0,0,0,.15); }
    #hint { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); z-index:10; font-size:12px; opacity:.8; background: rgba(255,255,255,.55); border:1px solid var(--glass); border-radius:10px; padding:6px 10px; backdrop-filter: blur(6px); color:#0b1220 }
    #perf { position:fixed; right:10px; bottom:10px; font-size:11px; opacity:.8; background: rgba(255,255,255,.55); border:1px solid var(--glass); padding:6px 10px; border-radius:10px; color:#0b1220 }
    #err { position: fixed; inset: 10px; background: rgba(0,0,0,.75); border: 1px solid #fff3; border-radius: 12px; padding: 12px; display:none; z-index: 20; overflow:auto; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; color: #fff; }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/loaders/RGBELoader.js"></script>
</head>
<body>
  <div id="app"><canvas id="c"></canvas></div>
  <div id="hud">
    <div class="tag">JEFFREY EPSTEIN ISLAND · sunny day</div>
  </div>
  <div id="hint">Свайп/Drag — перемещение · Пинч/Колёсико — зум · ПКМ — поворот по кругу</div>
  <div id="perf">FPS: <span id="fps">—</span></div>
  <div id="err"></div>

  <script>
  (function(){
    const errBox = document.getElementById('err');
    function showErr(msg) { errBox.style.display = 'block'; errBox.textContent = 'Ошибка:\\n' + msg; console.error(msg); }
    window.addEventListener('error', (e)=> showErr(e.message || e.error));
    window.addEventListener('unhandledrejection', (e)=> showErr(e.reason || 'unhandledrejection'));

    try { Telegram?.WebApp?.ready(); Telegram?.WebApp?.expand(); } catch(_) {}

    if (!window.THREE) { showErr('THREE.js не загрузился (CDN)'); return; }

    // ===== Сцена под MiniApp (адаптивный масштаб) =====
    // Автоматически подбираем размер острова под экран
    const minSide = Math.min(window.innerWidth, window.innerHeight);
    const ISLAND_SIZE = Math.max(420, Math.min(720, Math.round(minSide * 0.9))); // адаптивный, ≈ 70% экрана
    const OCEAN_SIZE  = Math.round(ISLAND_SIZE * 2.6);  // океан вокруг
    const HALF_I = ISLAND_SIZE/2, HALF_O = OCEAN_SIZE/2;

    const canvas = document.getElementById('c');
    let gl = canvas.getContext('webgl2', { antialias:true, alpha:false });
    if (!gl) gl = canvas.getContext('webgl', { antialias:true, alpha:false });
    if (!gl) { showErr('WebGL не доступен'); return; }

    const renderer = new THREE.WebGLRenderer({ canvas, context: gl, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(1.75, window.devicePixelRatio || 1)); // мягкий лимит DPI для MiniApp
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    renderer.setClearColor(0x87bce5, 1); // ясное небо

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87bce5, 0.00012); // лёгкая дневная дымка

    const camera = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, 0.8, 30000);

    // ===== Камера: вид сверху с фикс. наклоном, долли-зум, панорамирование =====
    const target = new THREE.Vector3(0,0,0);
    const BASE_PHI = THREE.MathUtils.degToRad(70); // ещё выше
    let spherical = new THREE.Spherical(HALF_I*1.9, BASE_PHI, THREE.MathUtils.degToRad(20));
    const minDistance = Math.max(140, HALF_I*0.9);
    const maxDistance = Math.min(HALF_O*0.95, HALF_I*3.0); // не уходим «за текстуры»
    const PAN_MARGIN = 24;

    function clampTargetOcean() {
      target.x = THREE.MathUtils.clamp(target.x, -HALF_O+PAN_MARGIN, HALF_O-PAN_MARGIN);
      target.z = THREE.MathUtils.clamp(target.z, -HALF_O+PAN_MARGIN, HALF_O-PAN_MARGIN);
    }
    function updateCamera(){
      clampTargetOcean();
      spherical.phi = BASE_PHI; // держим лёгкий наклон сверху
      const sinPhiRadius = spherical.radius * Math.sin(spherical.phi);
      camera.position.set(
        target.x + sinPhiRadius * Math.sin(spherical.theta),
        target.y + spherical.radius * Math.cos(spherical.phi),
        target.z + sinPhiRadius * Math.cos(spherical.theta)
      );
      camera.lookAt(target);
    }
    updateCamera();

    // ===== Управление: панорамирование (по умолчанию), колёсико/пинч — зум, ПКМ — поворот вокруг =====
    let state = null; // 'PAN' | 'ROTATE' | 'PINCH'
    let lastX=0, lastY=0, lastPinch=0;
    const panSpeed = 0.0022, rotateSpeed = 0.006, zoomSpeed = 1.0;

    function onDown(e){
      const isTouch = e.type === 'touchstart';
      if (isTouch && e.touches.length === 2){
        state = 'PINCH';
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastPinch = Math.hypot(dx, dy);
      } else {
        const btn = isTouch ? 0 : e.button;
        state = (btn===2) ? 'ROTATE' : 'PAN';
        const p = isTouch ? (e.touches[0]) : e;
        lastX = p.clientX; lastY = p.clientY;
      }
      e.preventDefault();
    }
    function onMove(e){
      if (!state) return;
      if (state === 'PINCH' && e.touches && e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        const delta = (lastPinch - dist) / 200.0;
        spherical.radius *= (1 + zoomSpeed * delta);
        spherical.radius = Math.max(minDistance, Math.min(maxDistance, spherical.radius));
        lastPinch = dist;
        updateCamera();
      } else {
        const p = e.touches? e.touches[0] : e;
        const dx = (p.clientX - lastX), dy = (p.clientY - lastY);
        lastX = p.clientX; lastY = p.clientY;
        if (state==='PAN'){
          const panX = -dx * panSpeed * (spherical.radius/800);
          const panZ =  dy * panSpeed * (spherical.radius/800);
          const mz = new THREE.Vector3(); camera.getWorldDirection(mz); mz.y=0; mz.normalize();
          const mx = new THREE.Vector3().crossVectors(camera.up, mz).normalize();
          target.addScaledVector(mx, panX).addScaledVector(mz, panZ);
        } else if (state==='ROTATE'){
          spherical.theta -= dx * rotateSpeed;
        }
        updateCamera();
      }
      e.preventDefault();
    }
    function onUp(){ state = null; }
    function onWheel(e){
      const delta = Math.sign(e.deltaY);
      spherical.radius *= (1 + zoomSpeed * 0.12 * delta);
      spherical.radius = Math.max(minDistance, Math.min(maxDistance, spherical.radius));
      updateCamera(); e.preventDefault();
    }
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    canvas.addEventListener('mouseup', onUp);
    canvas.addEventListener('mouseleave', onUp);
    canvas.addEventListener('wheel', onWheel, {passive:false});
    canvas.addEventListener('touchstart', onDown, {passive:false});
    canvas.addEventListener('touchmove', onMove, {passive:false});
    canvas.addEventListener('touchend', onUp);
    canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

    // ===== Свет: всегда солнечно =====
    const sun = new THREE.DirectionalLight(0xffffff, 1.35);
    sun.position.set(-1200, 1800, 800); scene.add(sun);
    const hemi = new THREE.HemisphereLight(0xcfe7ff, 0xf1f5f9, 0.85); scene.add(hemi);

    // ===== Перлин и террейн с богатой палитрой =====
    function rand(seed){ const x = Math.sin(seed)*10000; return x - Math.floor(x); }
    function makePerlin(seed){
      const p = new Uint8Array(512);
      for (let i=0;i<256;i++) p[i]=i;
      for (let i=255;i>0;i--){ const j = Math.floor(rand(seed+i)*256); const t=p[i]; p[i]=p[j]; p[j]=t; }
      for (let i=0;i<256;i++) p[256+i]=p[i];
      const grad = (h,x,y)=>{ switch(h&3){ case 0:return x+y; case 1:return -x+y; case 2:return x-y; default:return -x-y; } };
      const fade = (t)=> t*t*t*(t*(t*6-15)+10);
      const lerp = (a,b,t)=> a+(b-a)*t;
      return function(x,y){
        const X = Math.floor(x)&255, Y=Math.floor(y)&255;
        const xf=x-Math.floor(x), yf=y-Math.floor(y);
        const tr = p[p[X+1]+Y+1], tl=p[p[X]+Y+1], br=p[p[X+1]+Y], bl=p[p[X]+Y];
        const u=fade(xf), v=fade(yf);
        const x1=lerp(grad(bl, xf, yf), grad(br, xf-1, yf), u);
        const x2=lerp(grad(tl, xf, yf-1), grad(tr, xf-1, yf-1), u);
        return (lerp(x1, x2, v)+1)/2;
      }
    }
    const perlin = makePerlin(4242);

    function buildTerrain(res, scaleH){
      const geo = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, res, res);
      geo.rotateX(-Math.PI/2);
      const pos = geo.attributes.position;
      const colors = [];
      const v = new THREE.Vector3();
      function mix(a,b,t){ return a*(1-t)+b*t; }
      function colorLerp(c1,c2,t){ const c=new THREE.Color(); c.r=mix(c1.r,c2.r,t); c.g=mix(c1.g,c2.g,t); c.b=mix(c1.b,c2.b,t); return c; }
      const sand1=new THREE.Color('#f5e3be'), sand2=new THREE.Color('#e5d0a6');
      const plain1=new THREE.Color('#b79b69'), plain2=new THREE.Color('#9a7b52');
      const forest1=new THREE.Color('#2a8a57'), forest2=new THREE.Color('#1e6d3f');
      const jungle1=new THREE.Color('#71c47f'), jungle2=new THREE.Color('#3ba35f');
      const rock1=new THREE.Color('#5e6673'), rock2=new THREE.Color('#464b54');
      for (let i=0;i<pos.count;i++){
        v.fromBufferAttribute(pos, i);
        const nx = (v.x + HALF_I)/ISLAND_SIZE;
        const nz = (v.z + HALF_I)/ISLAND_SIZE;
        const h1 = perlin(nx*3.5, nz*3.5), h2=perlin(nx*7.5+100, nz*7.5-30), h3=perlin(nx*15-50, nz*15+50);
        let h = (h1*0.6 + h2*0.3 + h3*0.1);
        const ridge = Math.exp(-Math.pow((nx-0.5)*2.1, 2))*Math.exp(-Math.pow((nz-0.5)*2.1, 2));
        h += ridge*0.36;
        const edge = Math.min(nx, nz, 1-nx, 1-nz);
        let heightM = (h*78) * scaleH;
        if (edge < 0.075) heightM *= 0.42;
        pos.setY(i, heightM);

        const c = new THREE.Color();
        if (edge < 0.075) {
          c.copy(colorLerp(sand1, sand2, perlin(nx*6, nz*6)));
        } else if (heightM > 52) {
          c.copy(colorLerp(rock1, rock2, perlin(nx*4, nz*4)));
        } else {
          const biome = perlin(nx*2+7, nz*2-7);
          if (biome > 0.68) c.copy(colorLerp(forest1, forest2, perlin(nx*3, nz*3)));
          else if (biome > 0.5) c.copy(colorLerp(jungle1, jungle2, perlin(nx*3, nz*3)));
          else c.copy(colorLerp(plain1, plain2, perlin(nx*3, nz*3)));
        }
        colors.push(c.r,c.g,c.b);
      }
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
      geo.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({ vertexColors:true, metalness:0.05, roughness:0.92 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.frustumCulled = true;
      return mesh;
    }

    const terrainLOD = new THREE.LOD();
    terrainLOD.addLevel(buildTerrain(340, 1.0), 0);
    terrainLOD.addLevel(buildTerrain(200, 1.0), 360);
    terrainLOD.addLevel(buildTerrain(120, 1.0), 740);
    scene.add(terrainLOD);

    // ===== Океан (кастомный шейдер) =====
    const waterTex = new THREE.TextureLoader().load('assets/waternormals.jpg');
    waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping;
    const waterUniforms = {
      uTime: { value: 0.0 },
      uColor: { value: new THREE.Color('#0d3b66') },
      uNormalMap: { value: waterTex },
      uSunDir: { value: new THREE.Vector3(0.3,1,0.2).normalize() }
    };
    const waterMat = new THREE.ShaderMaterial({
      uniforms: waterUniforms,
      transparent: false,
      vertexShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          vUv = uv * 18.0 + vec2(uTime*0.02, uTime*0.015);
          vec3 pos = position;
          pos.z += sin((position.x + uTime*2.0)*0.03)*0.6;
          pos.x += cos((position.y + uTime*1.6)*0.03)*0.6;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform sampler2D uNormalMap;
        uniform vec3 uSunDir;
        varying vec2 vUv;
        void main(){
          vec3 n = texture2D(uNormalMap, vUv).xyz * 2.0 - 1.0;
          n = normalize(vec3(n.x, n.z, n.y));
          float ndl = clamp(dot(n, normalize(uSunDir)), 0.0, 1.0);
          vec3 col = uColor * (0.62 + 0.38*ndl);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const waterGeom = new THREE.PlaneGeometry(OCEAN_SIZE, OCEAN_SIZE, 160, 160);
    const water = new THREE.Mesh(waterGeom, waterMat);
    water.rotation.x = -Math.PI/2;
    water.position.y = 0.1;
    scene.add(water);

    // ===== Растительность и мелкие объекты (масштабы гармонизированы) =====
    function sampleHeightAt(x, z) {
      const nx = (x + HALF_I)/ISLAND_SIZE, nz = (z + HALF_I)/ISLAND_SIZE;
      const h1 = perlin(nx*3.5, nz*3.5), h2 = perlin(nx*7.5+100, nz*7.5-30), h3 = perlin(nx*15-50, nz*15+50);
      let h = (h1*0.6 + h2*0.3 + h3*0.1);
      const ridge = Math.exp(-Math.pow((nx-0.5)*2.1, 2))*Math.exp(-Math.pow((nz-0.5)*2.1, 2));
      h += ridge*0.36;
      const edge = Math.min(nx, nz, 1-nx, 1-nz);
      let heightM = (h*78);
      if (edge < 0.075) heightM *= 0.42;
      return heightM;
    }

    // пальмы
    const palmCount = Math.round(220 * (ISLAND_SIZE/700));
    const trunkGeo = new THREE.CylinderGeometry(0.2, 0.32, 6.2, 6, 1, false);
    const trunkMat = new THREE.MeshStandardMaterial({ color:'#7b5a39', roughness:0.9 });
    const trunkInst = new THREE.InstancedMesh(trunkGeo, trunkMat, palmCount);
    const leafGeo = new THREE.ConeGeometry(1.1, 2.1, 7);
    const leafMat = new THREE.MeshStandardMaterial({ color:'#2a8a57', roughness:0.68, metalness:0.02 });
    const leafInst = new THREE.InstancedMesh(leafGeo, leafMat, palmCount*4);

    const bananaCount = Math.round(18 * (ISLAND_SIZE/700));
    const bananaTrunk = new THREE.CylinderGeometry(0.16, 0.26, 4.6, 6);
    const bananaLeaf = new THREE.ConeGeometry(0.9, 1.8, 8);
    const bananaTrInst = new THREE.InstancedMesh(bananaTrunk, new THREE.MeshStandardMaterial({color:'#6e5a33'}), bananaCount);
    const bananaLfInst = new THREE.InstancedMesh(bananaLeaf, new THREE.MeshStandardMaterial({color:'#3bbf6a'}), bananaCount*3);

    const fernCount = Math.round(120 * (ISLAND_SIZE/700));
    const fernGeo = new THREE.ConeGeometry(0.8, 0.9, 7);
    const fernMat = new THREE.MeshStandardMaterial({ color:'#3fa068', roughness:0.85 });
    const fernInst = new THREE.InstancedMesh(fernGeo, fernMat, fernCount);

    const flowerCount = Math.round(280 * (ISLAND_SIZE/700));
    const flowerGeo = new THREE.SphereGeometry(0.12, 6, 6);
    const flowers = new THREE.InstancedMesh(flowerGeo, new THREE.MeshStandardMaterial({ color:'#ffffff', roughness:0.5, metalness:0.0 }), flowerCount);

    const rockCount = Math.round(90 * (ISLAND_SIZE/700));
    const rockGeo = new THREE.DodecahedronGeometry(0.9);
    const rocks = new THREE.InstancedMesh(rockGeo, new THREE.MeshStandardMaterial({ color:'#6e737c', roughness:0.95, metalness:0.03 }), rockCount);

    const m4 = new THREE.Matrix4(); const q = new THREE.Quaternion(); const v3 = new THREE.Vector3();

    function jitterColor(baseHex, amt=0.08){
      const c = new THREE.Color(baseHex);
      const hsl = {h:0,s:0,l:0}; c.getHSL(hsl);
      hsl.h = (hsl.h + (Math.random()*2-1)*amt) % 1;
      hsl.s = THREE.MathUtils.clamp(hsl.s + (Math.random()*2-1)*amt, 0, 1);
      hsl.l = THREE.MathUtils.clamp(hsl.l + (Math.random()*2-1)*amt, 0, 1);
      const out = new THREE.Color(); out.setHSL(hsl.h, hsl.s, hsl.l); return out;
    }

    let leafIndex = 0, bananaLeafIndex = 0;
    for (let i=0; i<palmCount; i++) {
      let x, z;
      for (let tries=0; tries<800; tries++){
        x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
        z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
        const nx = (x + HALF_I)/ISLAND_SIZE, nz=(z+HALF_I)/ISLAND_SIZE;
        const edge = Math.min(nx, nz, 1-nx, 1-nz);
        const nearBeach = edge < 0.12;
        const ok = Math.random() < (nearBeach? 0.7 : 0.35);
        const h = sampleHeightAt(x,z);
        if (ok && h > 1 && h < 46) break;
      }
      const y = sampleHeightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.85, 1.18);
      const rotY = THREE.MathUtils.randFloat(0, Math.PI*2);
      q.setFromAxisAngle(new THREE.Vector3(0,1,0), rotY);
      m4.compose(new THREE.Vector3(x, y+3.2*s, z), q, new THREE.Vector3(1, s, 1));
      trunkInst.setMatrixAt(i, m4);
      for (let k=0;k<4;k++) {
        const ry = rotY + k*(Math.PI/2) + THREE.MathUtils.randFloat(-0.15,0.15);
        const up = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.6+THREE.MathUtils.randFloat(-0.2,0.2), ry, 0));
        const scale = THREE.MathUtils.randFloat(0.78,1.15);
        m4.compose(new THREE.Vector3(x, y+6.6*s, z), up, new THREE.Vector3(scale, scale, scale));
        leafInst.setMatrixAt(leafIndex++, m4);
      }
    }
    for (let i=0;i<bananaCount;i++){
      const x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.7);
      const z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.7);
      const y = sampleHeightAt(x,z);
      m4.compose(new THREE.Vector3(x, y+2.1, z), new THREE.Quaternion(), new THREE.Vector3(1,1,1));
      bananaTrInst.setMatrixAt(i, m4);
      for (let k=0;k<3;k++){
        const rotY = THREE.MathUtils.randFloat(0, Math.PI*2);
        m4.compose(new THREE.Vector3(x, y+3.0, z), new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.4, rotY, 0)), new THREE.Vector3(1,1,1));
        bananaLfInst.setMatrixAt(bananaLeafIndex++, m4);
      }
    }
    for (let i=0;i<fernCount;i++){
      const x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.8);
      const z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.8);
      const y = sampleHeightAt(x,z);
      m4.compose(new THREE.Vector3(x, y+0.5, z), new THREE.Quaternion(), new THREE.Vector3(1,1,1));
      fernInst.setMatrixAt(i, m4);
    }
    for (let i=0;i<flowerCount;i++){
      const x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
      const z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
      const y = sampleHeightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.8, 1.8);
      m4.compose(new THREE.Vector3(x, y+0.1, z), new THREE.Quaternion(), new THREE.Vector3(s,s,s));
      flowers.setMatrixAt(i, m4);
      flowers.setColorAt(i, jitterColor(i%3===0?'#ffffff':(i%3===1?'#ffefd5':'#e6f7d9')));
    }
    for (let i=0;i<rockCount;i++){
      const x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.85);
      const z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.85);
      const y = sampleHeightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.6, 2.4);
      q.setFromEuler(new THREE.Euler(Math.random()*0.2, Math.random()*Math.PI*2, Math.random()*0.2));
      m4.compose(new THREE.Vector3(x, y+0.5*s, z), q, new THREE.Vector3(s,s,s));
      rocks.setMatrixAt(i, m4);
    }
    scene.add(trunkInst, leafInst, bananaTrInst, bananaLfInst, fernInst, flowers, rocks);

    // ===== Дороги, пирс, лодки, хелипад — масштабированы =====
    function makeRoad(x1,z1,x2,z2,width=3.2,color=0x515151){
      const len = Math.hypot(x2-x1, z2-z1);
      const geo = new THREE.BoxGeometry(width, 0.18, len);
      const mat = new THREE.MeshStandardMaterial({ color, roughness:0.95, metalness:0.02 });
      const m = new THREE.Mesh(geo, mat);
      m.position.set((x1+x2)/2, sampleHeightAt((x1+x2)/2,(z1+z2)/2)+0.10, (z1+z2)/2);
      m.rotation.y = Math.atan2(x2-x1, z2-z1);
      scene.add(m);
    }

    const hub = new THREE.Vector3(0,0,0);
    const villaSpots = [
      new THREE.Vector3(-ISLAND_SIZE*0.25,0,  ISLAND_SIZE*0.12),
      new THREE.Vector3( ISLAND_SIZE*0.23,0,  ISLAND_SIZE*0.15),
      new THREE.Vector3(-ISLAND_SIZE*0.18,0,-ISLAND_SIZE*0.2),
      new THREE.Vector3( ISLAND_SIZE*0.20,0,-ISLAND_SIZE*0.23),
      new THREE.Vector3(  ISLAND_SIZE*0.02,0, ISLAND_SIZE*0.28)
    ];
    villaSpots.forEach(v=> makeRoad(hub.x, hub.z, v.x, v.z, 3.4, 0x4a4a4a));

    const pierPos = new THREE.Vector3(0,0, HALF_I-35);
    makeRoad(hub.x, hub.z, pierPos.x, pierPos.z, 3.0, 0x3d3d3d);
    const pier = new THREE.Mesh(new THREE.BoxGeometry(9,1,36), new THREE.MeshStandardMaterial({color:'#6b5843', roughness:0.85}));
    pier.position.set(pierPos.x, sampleHeightAt(pierPos.x,pierPos.z)+1, pierPos.z+20);
    scene.add(pier);

    function makeBoat(x,z){
      const g = new THREE.Group();
      const hull = new THREE.Mesh(new THREE.BoxGeometry(4.5,1.1,8.5), new THREE.MeshStandardMaterial({ color:'#b8c1c7', metalness:0.2, roughness:0.6 }));
      hull.position.y = 0.7; g.add(hull);
      const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,3.8,6), new THREE.MeshStandardMaterial({ color:'#e7ecef' }));
      mast.position.y = 2.9; g.add(mast);
      g.position.set(x, 0.55, z);
      g.userData.baseY = 0.55;
      return g;
    }
    const boats = [
      makeBoat(pier.position.x+10, pier.position.z+15),
      makeBoat(pier.position.x-8,  pier.position.z+13),
      makeBoat(pier.position.x+ 1, pier.position.z+21)
    ];
    boats.forEach(b=> scene.add(b));

    const helipad = new THREE.Mesh(new THREE.CylinderGeometry(8,8,1,48), new THREE.MeshStandardMaterial({color:'#e5e7eb', roughness:0.7}));
    const helix = new THREE.Mesh(new THREE.RingGeometry(1.6,5,48), new THREE.MeshBasicMaterial({color:'#ffffff'}));
    helix.rotation.x = -Math.PI/2; helipad.add(helix);
    const hlabel = new THREE.Mesh(new THREE.PlaneGeometry(3,3), new THREE.MeshBasicMaterial({color:'#ffffff'}));
    hlabel.rotation.x = -Math.PI/2; hlabel.position.y = 0.6; helipad.add(hlabel);
    helipad.position.set(-HALF_I*0.52, sampleHeightAt(-HALF_I*0.52, -HALF_I*0.18)+1, -HALF_I*0.18);
    scene.add(helipad);

    function buildCastle(){
      const group = new THREE.Group();
      const baseMat = new THREE.MeshStandardMaterial({ color:'#9aa2ab', metalness:0.12, roughness:0.48 });
      const glassMat = new THREE.MeshPhysicalMaterial({ color:'#bfe7ff', metalness:0.0, roughness:0.12, transmission:0.0 });
      const body = new THREE.Mesh(new THREE.BoxGeometry(36, 22, 26), baseMat);
      body.position.y = 11; group.add(body);
      const towerMat = new THREE.MeshStandardMaterial({ color:'#8b929b', metalness:0.1, roughness:0.5 });
      const r = 22;
      for (let i=0;i<8;i++){
        const ang = i * Math.PI/4;
        const tx = Math.cos(ang)*r, tz = Math.sin(ang)*r;
        const tower = new THREE.Mesh(new THREE.CylinderGeometry(4,4,18,12), towerMat);
        tower.position.set(tx, 9, tz);
        group.add(tower);
      }
      const glass = new THREE.Mesh(new THREE.BoxGeometry(24, 6, 3), glassMat);
      glass.position.set(0, 17, 14); group.add(glass);
      const chimneys = [];
      for (let i=0;i<3;i++){
        const ch = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,4.2,8), new THREE.MeshStandardMaterial({color:'#6e6e6e'}));
        ch.position.set(-6 + i*6, 13, 0);
        chimneys.push(ch); group.add(ch);
      }
      group.userData.chimneys = chimneys;
      group.position.set(0, sampleHeightAt(0,0), 0);
      scene.add(group);
      return group;
    }
    const castle = buildCastle();

    function makeModernVilla(pos){
      const mat = new THREE.MeshStandardMaterial({ color:'#d7dade', metalness:0.05, roughness:0.6 });
      const g = new THREE.Group();
      const b1 = new THREE.Mesh(new THREE.BoxGeometry(12, 6, 8), mat); b1.position.y = 3; g.add(b1);
      const b2 = new THREE.Mesh(new THREE.BoxGeometry(10, 4.5, 7), new THREE.MeshStandardMaterial({color:'#c3c7cd', roughness:0.55}));
      b2.position.set(0, 7.5, -1.2); g.add(b2);
      g.position.set(pos.x, sampleHeightAt(pos.x,pos.z), pos.z);
      scene.add(g);
    }
    function makeBungalow(pos){
      const mat = new THREE.MeshStandardMaterial({ color:'#8a6a4a', roughness:0.9 });
      const g = new THREE.Group();
      const base = new THREE.Mesh(new THREE.BoxGeometry(7.5, 3.2, 7.5), mat); base.position.y = 1.6; g.add(base);
      const roof = new THREE.Mesh(new THREE.ConeGeometry(5.4, 3.2, 6), new THREE.MeshStandardMaterial({ color:'#7a5a3a', roughness:0.9 }));
      roof.position.y = 4.8; g.add(roof);
      g.position.set(pos.x, sampleHeightAt(pos.x,pos.z), pos.z);
      scene.add(g);
    }

    [-ISLAND_SIZE*0.25, ISLAND_SIZE*0.23, -ISLAND_SIZE*0.18, ISLAND_SIZE*0.20, ISLAND_SIZE*0.02].forEach((vx,i)=> makeModernVilla(new THREE.Vector3(vx,0, [ISLAND_SIZE*0.12, ISLAND_SIZE*0.15, -ISLAND_SIZE*0.2, -ISLAND_SIZE*0.23, ISLAND_SIZE*0.28][i])));
    const bunPos = [
      new THREE.Vector3(-ISLAND_SIZE*0.31,0, ISLAND_SIZE*0.06), new THREE.Vector3(ISLAND_SIZE*0.31,0,  ISLAND_SIZE*0.08),
      new THREE.Vector3(-ISLAND_SIZE*0.29,0,-ISLAND_SIZE*0.09), new THREE.Vector3(ISLAND_SIZE*0.27,0,-ISLAND_SIZE*0.11),
      new THREE.Vector3(-ISLAND_SIZE*0.09,0, ISLAND_SIZE*0.31), new THREE.Vector3(ISLAND_SIZE*0.09,0, ISLAND_SIZE*0.30),
      new THREE.Vector3(0,0,-ISLAND_SIZE*0.30)
    ];
    bunPos.forEach(makeBungalow);

    // Птицы (5 групп)
    const birdGroups = [];
    function makeBirdGroup(radius, height, speed, count, color=0xffffff){
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(count*3);
      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const mat = new THREE.PointsMaterial({ color, size: 2, sizeAttenuation: true });
      const pts = new THREE.Points(geom, mat);
      pts.userData = { radius, height, speed, phase: Math.random()*Math.PI*2 };
      birdGroups.push(pts); scene.add(pts);
    }
    makeBirdGroup(ISLAND_SIZE*0.25,  ISLAND_SIZE*0.22, 0.40, 60, 0xffffff);
    makeBirdGroup(ISLAND_SIZE*0.32,  ISLAND_SIZE*0.28, 0.33, 80, 0xfff3bf);
    makeBirdGroup(ISLAND_SIZE*0.20,  ISLAND_SIZE*0.24, 0.50, 50, 0xe3fafc);
    makeBirdGroup(ISLAND_SIZE*0.37,  ISLAND_SIZE*0.33, 0.29, 70, 0xf1f3f5);
    makeBirdGroup(ISLAND_SIZE*0.28,  ISLAND_SIZE*0.26, 0.36, 70, 0xffffff);

    // ===== Анимация =====
    function onResize(){
      const dpr = Math.min(1.75, window.devicePixelRatio||1);
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setPixelRatio(dpr); renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    const fpsEl = document.getElementById('fps');
    let lastTime = performance.now(), frames = 0, t = 0;
    function loop(){
      t += 0.016;
      waterUniforms.uTime.value = t;
      // лодки
      scene.traverse((obj)=>{
        if (obj.userData && obj.userData.baseY) {
          obj.position.y = obj.userData.baseY + Math.sin(t*1.1 + obj.id*0.3)*0.14;
        }
      });
      // дым из труб
      if (castle && castle.userData && castle.userData.chimneys){
        castle.userData.chimneys.forEach((ch, idx)=>{
          const f = (t*0.6 + idx) % (Math.PI*2);
          ch.position.y = 13 + Math.sin(f)*0.15;
        });
      }
      // птицы
      birdGroups.forEach(g=>{
        const u = g.userData; const ang = t*u.speed + u.phase;
        g.position.set(Math.cos(ang)*u.radius, u.height, Math.sin(ang)*u.radius);
      });
      renderer.render(scene, camera);
      frames++; const now = performance.now();
      if (now - lastTime > 500) { fpsEl.textContent = Math.round(1000*frames/(now-lastTime)); frames = 0; lastTime = now; }
      requestAnimationFrame(loop);
    }
    onResize(); loop();

    try { Telegram.WebApp.onEvent('backButtonClicked', () => Telegram.WebApp.close()); Telegram.WebApp.BackButton.show(); } catch(_) {}
  })();
  </script>
</body>
</html>
