<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
  <title>Остров Навигации — Three.js r128 (Legacy/No-Module)</title>
  <meta name="description" content="Процедурный 3D-остров без ES Modules — совместимо с строгими WebView (Telegram MiniApps).">
  <style>
    :root{ --glass:#ffffffcc; --glass2:#ffffffaa; --mint:#36c2b6; }
    html,body{height:100%; margin:0; background:#0b1727; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    #app{position:fixed; inset:0; overflow:hidden;}
    canvas{display:block; width:100%; height:100%;}
    .hud{position:fixed; left:0; right:0; pointer-events:none;}
    .hud-top{top:0; padding:12px; display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .brand{pointer-events:auto; backdrop-filter:saturate(140%) blur(8px); background:var(--glass); border:1px solid #ffffff55; border-radius:14px; padding:10px 14px; display:flex; gap:10px; align-items:center; box-shadow:0 8px 30px rgba(0,0,0,.18);}
    .brand h1{font-size:14px; font-weight:700; margin:0; color:#0a0f18;}
    .brand span{font-size:12px; color:#1b2a42; opacity:.9}
    .panel{pointer-events:auto; display:flex; gap:8px; align-items:center;}
    .chip{user-select:none; cursor:pointer; backdrop-filter:saturate(140%) blur(8px); background:var(--glass2); border:1px solid #ffffff55; border-radius:12px; padding:8px 10px; font-size:12px; color:#0a0f18; box-shadow:0 6px 24px rgba(0,0,0,.15);}
    .chip.active{background:#e9fffb; border-color:#8fe7dc; color:#064f49;}
    .btn{user-select:none; cursor:pointer; border-radius:12px; padding:8px 12px; font-size:12px; background:#e9fffb; border:1px solid #8fe7dc; color:#064f49; box-shadow:0 6px 24px rgba(0,0,0,.15);}
    .hud-bottom{bottom:0; display:flex; justify-content:center; padding:18px;}
    .hint{pointer-events:none; background:var(--glass2); border:1px solid #ffffff55; border-radius:14px; padding:10px 14px; font-size:12px; color:#0a0f18; opacity:1; transform:translateY(0); transition:opacity .6s ease, transform .6s ease;}
    .hint.hide{opacity:0; transform:translateY(8px);}
    .corner{position:fixed; right:12px; bottom:12px; display:flex; gap:8px; align-items:flex-end; pointer-events:none;}
    .meter{pointer-events:auto; background:var(--glass2); border:1px solid #ffffff55; border-radius:12px; padding:10px 12px; font-size:12px; color:#0a0f18; min-width:140px; box-shadow:0 6px 24px rgba(0,0,0,.15);}
    .bar{height:6px; background:#d7efe9; border-radius:6px; overflow:hidden; margin-top:6px;}
    .bar>i{display:block; height:100%; width:30%; background:var(--mint);}
    .toast{pointer-events:auto; background:#101828; color:#eafffb; border:1px solid #1f2b3b; border-radius:12px; padding:10px 12px; font-size:12px; opacity:.95}
    .log{position:fixed; left:12px; bottom:12px; right:180px; pointer-events:none; color:#fefefe; font:12px/1.4 ui-monospace,Consolas,monospace; opacity:.9}
    .log pre{background:#0008; padding:8px 10px; border-radius:10px; max-height:40vh; overflow:auto; margin:0}
  </style>
  <!-- Three.js (UMD) + examples (non-module) -->
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
</head>
<body>
  <div id="app"></div>
  <div class="hud hud-top">
    <div class="brand">
      <div style="width:10px; height:10px; border-radius:50%; background:#36c2b6; box-shadow:0 0 0 4px #36c2b622"></div>
      <div>
        <h1>Остров навигации <span style="background:#e5fbf8; color:#0b4d46; border:1px solid #8fe7dc; border-radius:999px; padding:2px 8px; font-size:10px; margin-left:6px;">legacy</span></h1>
        <span>UMD-only • FXAA + Bloom • WebGL1/2 fallback</span>
      </div>
    </div>
    <div class="panel">
      <div class="chip" data-q="auto">Quality: Auto</div>
      <div class="chip" data-q="low">Low</div>
      <div class="chip" data-q="high">High</div>
      <div class="btn" id="resetView">Reset View</div>
    </div>
  </div>
  <div class="hud hud-bottom">
    <div class="hint" id="hint">Пан — ЛКМ/один палец • Зум — колесо/пинч • Поворот — ПКМ/двумя пальцами</div>
  </div>
  <div class="corner">
    <div class="meter">
      <div><b id="fps">FPS: —</b></div>
      <div id="gpu">GPU load: —</div>
      <div class="bar"><i id="gpuBar" style="width:0%"></i></div>
    </div>
    <div class="toast" id="toast" style="display:none"></div>
  </div>
  <div class="log"><pre id="log"></pre></div>

  <script>
  (function(){
    const logEl = document.getElementById('log');
    const log = (...a)=>{ try{ logEl.textContent += a.join(' ') + "\\n"; }catch(e){} };
    window.addEventListener('error', e=>{ log("Error:", e.message); });
    window.addEventListener('unhandledrejection', e=>{ log("Promise:", e.reason && e.reason.message || e.reason); });

    try{
      const THREE_NS = window.THREE;
      if(!THREE_NS) { log("THREE not found"); return; }

      // ===== CONFIG =====
      const CONFIG = {
        island:{ size:2400, oceanSize:12000, maxHeight:110, beachBand:0.15, terrainSegments:{low:96,auto:160,high:224}, lodDistances:[0,1800,3200] },
        camera:{ phiDeg:70, thetaDeg:-30, minDistance:100, maxDistance:2000, startDistance:950, startHeight:500, boundsPad:600 },
        post:{ bloom:{ intensity:0.9, radius:0.45, threshold:0.82 } },
        palette:{ sandA:0xf5e3be, sandB:0xe5d0a6, plainsA:0xb79b69, plainsB:0x9a7b52, forestA:0x3ba35f, forestB:0x2a8a57, lime:0xb6f5b1, rockA:0x5e6673, rockB:0x464b54, oceanDeep:0x0d3b66, oceanShallowA:0x38bdf8, oceanShallowB:0x7cd4ff },
        vegetation:{ palms:{auto:320,low:220,high:480}, wind:0.5 },
        architecture:{ castle:{ size:[36,26,22] }, villas:{ concrete:5, bungalows:7 } },
        birds:5, boats:3, targetFPS:60
      };

      const app = document.getElementById('app');
      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.08;
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x0b1422, 0.002);

      const skyGeo = new THREE.SphereBufferGeometry(80000,16,16);
      const skyMat = new THREE.ShaderMaterial({
        side:THREE.BackSide,
        uniforms:{ top:{value:new THREE.Color(0x6bb7ff)}, middle:{value:new THREE.Color(0xbfe7ff)}, bottom:{value:new THREE.Color(0xf6f9ff)}, t:{value:0.0} },
        vertexShader:"varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",
        fragmentShader:"uniform vec3 top; uniform vec3 middle; uniform vec3 bottom; uniform float t; varying vec3 vPos; void main(){ float h=normalize(vPos).y*0.5+0.5; vec3 c=mix(mix(bottom,middle,smoothstep(0.2,0.7,h)), top, smoothstep(0.7,1.0,h)); gl_FragColor=vec4(c,1.0);}"
      });
      scene.add(new THREE.Mesh(skyGeo, skyMat));

      const hemi = new THREE.HemisphereLight(0xcfe8ff, 0x0f1a24, 0.55); scene.add(hemi);
      const sun = new THREE.DirectionalLight(0xffffff, 1.05); sun.position.set(1,1.2,0.8).multiplyScalar(5000); scene.add(sun);

      const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 100000);
      const center = new THREE.Vector3(0,0,0);
      let cameraDistance = CONFIG.camera.startDistance;
      let cameraTheta = THREE.MathUtils.degToRad(CONFIG.camera.thetaDeg);
      const cameraPhi = THREE.MathUtils.degToRad(CONFIG.camera.phiDeg);
      function placeCamera(){
        const x=Math.cos(cameraPhi)*Math.cos(cameraTheta)*cameraDistance;
        const z=Math.cos(cameraPhi)*Math.sin(cameraTheta)*cameraDistance;
        const y=Math.sin(cameraPhi)*cameraDistance;
        camera.position.set(center.x+x, CONFIG.camera.startHeight + y, center.z+z);
        camera.lookAt(center);
      }
      placeCamera();

      const ISLAND = CONFIG.island, HALF = ISLAND.size*0.5;
      const terrainGroup = new THREE.Group(); scene.add(terrainGroup);

      function vnoiseJS(x,z){ const ix=Math.floor(x), iz=Math.floor(z); const fx=x-ix, fz=z-iz;
        function rnd(i,j){ let t=(i*374761393 + j*668265263)>>>0; t=(t^(t>>13))*1274126177>>>0; return (t & 0xffff)/0xffff; }
        const a=rnd(ix,iz), b=rnd(ix+1,iz), c=rnd(ix,iz+1), d=rnd(ix+1,iz+1);
        const ux=fx*fx*(3-2*fx), uz=fz*fz*(3-2*fz);
        return (a*(1-ux)+b*ux)+ (c-a)*uz*(1-ux) + (d-b)*ux*uz;
      }
      function fbmJS(x,z){ let a=.5,f=0,px=x,pz=z; for(let i=0;i<5;i++){ f+=a*vnoiseJS(px,pz); px*=2.02; pz*=2.02; a*=.5;} return f; }
      function heightAt(x,z){
        const s = 1.0/420.0; const nx=x*s, nz=z*s;
        const r = Math.sqrt(nx*nx+nz*nz); const rim = THREE.MathUtils.clamp(1.0 - r*0.95, 0, 1);
        let h = (fbmJS(nx,nz)*0.75 + 0.25*fbmJS(nx*1.8,nz*1.8));
        h += 0.25*Math.exp(-Math.pow((x)/900,2))*Math.abs(Math.sin(z/300));
        h *= rim; return h*ISLAND.maxHeight;
      }

      const GLSL_NOISE = "uint hash(uvec2 x){ x=(x*1664525u+1013904223u); x^=(x.yx>>16); return x.x*1103515245u+x.y;} float rnd(vec2 uv){ return float(hash(uvec2(uv)))/4294967295.0;} float vnoise(in vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=rnd(i), b=rnd(i+vec2(1,0)), c=rnd(i+vec2(0,1)), d=rnd(i+vec2(1,1)); vec2 u=f*f*(3.0-2.0*f); return mix(a,b,u.x)+ (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;} float fbm(vec2 p){ float a=.5; float f=0.; for(int i=0;i<5;i++){ f += a*vnoise(p); p*=2.02; a*=.5; } return f; }";

      const TERRAIN_GLSL = GLSL_NOISE + "uniform float uMaxH; uniform float uSize; float hFunc(vec2 xz){ vec2 p=xz/420.0; float r=length(p); float rim=clamp(1.0-r*0.95,0.0,1.0); float n=0.0; float a=0.5; vec2 pp=p; for(int i=0;i<5;i++){ n+=a*vnoise(pp); pp*=2.02; a*=.5;} n = n*0.75 + 0.25*fbm(p*1.8); n += 0.25*exp(-pow(xz.x/900.0,2.0))*abs(sin(xz.y/300.0)); n*=rim; return n*uMaxH;} vec3 calcNormal(vec2 xz){ float e=1.0; float hC=hFunc(xz); float hx=hFunc(xz+vec2(e,0.0)); float hz=hFunc(xz+vec2(0.0,e)); vec3 n=normalize(cross(vec3(e,hx-hC,0.0), vec3(0.0,hz-hC,e))); return n; }";

      function makeTerrainMaterial(){
        const uniforms = {
          uMaxH:{value:ISLAND.maxHeight},
          uSize:{value:ISLAND.size},
          uSunDir:{value:new THREE.Vector3().copy(sun.position).normalize()},
          uColors:{value:[ new THREE.Color(CONFIG.palette.sandA), new THREE.Color(CONFIG.palette.sandB), new THREE.Color(CONFIG.palette.plainsA), new THREE.Color(CONFIG.palette.plainsB), new THREE.Color(CONFIG.palette.forestA), new THREE.Color(CONFIG.palette.forestB), new THREE.Color(CONFIG.palette.rockA), new THREE.Color(CONFIG.palette.rockB), new THREE.Color(CONFIG.palette.lime) ]},
          uTime:{value:0.0}
        };
        return new THREE.ShaderMaterial({
          uniforms, fog:true,
          vertexShader: TERRAIN_GLSL + "varying vec3 vPos; varying vec3 vNormal; varying float vH; varying vec2 vXZ; void main(){ vec3 p=position; float h=hFunc(p.xz); p.y=h; vPos=p; vH=h; vXZ=p.xz; vNormal=calcNormal(p.xz); gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}",
          fragmentShader: TERRAIN_GLSL + "varying vec3 vPos; varying vec3 vNormal; varying float vH; varying vec2 vXZ; uniform vec3 uSunDir; uniform vec3 uColors[9]; uniform float uTime; #define saturate(x) clamp(x,0.,1.) void main(){ vec3 N=normalize(vNormal); float slope=1.0 - N.y; float h01=saturate(vH/110.0); float n=fbm(vXZ/140.0); float wSand=smoothstep(0.0,0.09,h01)*smoothstep(0.195,0.09,h01); float wPlains=smoothstep(0.1,0.5,h01)*(1.0-smoothstep(0.55,0.7,h01))*(1.0-slope*0.8); float wForest=smoothstep(0.25,0.7,h01)*(1.0-smoothstep(0.7,0.82,h01))*(1.0-slope*0.6); float wRock=smoothstep(0.6,0.8,h01)*smoothstep(0.2,0.8,slope); wPlains*=mix(0.9,1.1,n); wForest*=mix(0.9,1.1, fbm(vXZ/90.0)); wRock*=mix(0.95,1.1, fbm(vXZ/60.0)); float sum=wSand+wPlains+wForest+wRock+1e-5; wSand/=sum; wPlains/=sum; wForest/=sum; wRock/=sum; vec3 sand=mix(uColors[0],uColors[1], fbm(vXZ/40.0)); vec3 plains=mix(uColors[2],uColors[3], fbm(vXZ/60.0)); vec3 forest=mix(uColors[4],uColors[5], fbm(vXZ/50.0)); vec3 rock=mix(uColors[6],uColors[7], fbm(vXZ/30.0)); vec3 albedo=sand*wSand + plains*wPlains + forest*wForest + rock*wRock; albedo*=mix(0.96,1.04, vnoise(vXZ/20.0)); float NdotL=saturate(dot(N, normalize(uSunDir))); float diff=mix(0.3,1.0,NdotL); float rough=mix(0.8,0.4,wRock)*mix(1.0,0.8,wSand); float spec=pow(saturate(dot(reflect(-normalize(uSunDir),N), normalize(vec3(0,1,0)))), mix(32.0,128.0,1.0-rough))*0.08; vec3 color=albedo*diff + vec3(spec); color+=vec3(0.06,0.09,0.11); gl_FragColor=vec4(color,1.0); #include <tonemapping_fragment> #include <encodings_fragment> }"
        });
      }

      function makeTerrainLOD(seg){
        const LODobj = new THREE.LOD();
        const mats=[makeTerrainMaterial(), makeTerrainMaterial(), makeTerrainMaterial()];
        const segs=[seg, Math.floor(seg*0.6), Math.floor(seg*0.32)];
        const distances=CONFIG.island.lodDistances;
        for(let i=0;i<3;i++){
          const geo = new THREE.PlaneBufferGeometry(ISLAND.size, ISLAND.size, segs[i], segs[i]);
          geo.rotateX(-Math.PI/2);
          const mesh = new THREE.Mesh(geo, mats[i]);
          mesh.frustumCulled = true;
          LODobj.addLevel(mesh, distances[i]);
        }
        return LODobj;
      }

      const normalA = (function makeNormalMap(size){ const data=new Uint8Array(size*size*4); for(let y=0;y<size;y++){ for(let x=0;x<size;x++){ const i=(y*size+x)*4; const a=Math.sin(x*0.12)+Math.cos(y*0.05); const b=Math.cos(x*0.07)+Math.sin(y*0.1); const nx=(a*0.5+0.5)*255; const ny=(b*0.5+0.5)*255; data[i]=nx; data[i+1]=ny; data[i+2]=255; data[i+3]=255; } } const tex=new THREE.DataTexture(data,size,size,THREE.RGBAFormat); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.needsUpdate=true; return tex; })(128);
      const normalB = (function makeNormalMap(size){ const data=new Uint8Array(size*size*4); for(let y=0;y<size;y++){ for(let x=0;x<size;x++){ const i=(y*size+x)*4; const a=Math.sin(x*0.18)+Math.cos(y*0.08); const b=Math.cos(x*0.09)+Math.sin(y*0.12); const nx=(a*0.5+0.5)*255; const ny=(b*0.5+0.5)*255; data[i]=nx; data[i+1]=ny; data[i+2]=255; data[i+3]=255; } } const tex=new THREE.DataTexture(data,size,size,THREE.RGBAFormat); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.needsUpdate=true; return tex; })(64);

      const waterUniforms={ uTime:{value:0}, uSunDir:{value:new THREE.Vector3().copy(sun.position).normalize()}, uDeep:{value:new THREE.Color(CONFIG.palette.oceanDeep)}, uShallowA:{value:new THREE.Color(CONFIG.palette.oceanShallowA)}, uShallowB:{value:new THREE.Color(CONFIG.palette.oceanShallowB)}, uNormalsA:{value:normalA}, uNormalsB:{value:normalB}, uSize:{value:ISLAND.size}, uOceanSize:{value:CONFIG.island.oceanSize}, uMaxH:{value:ISLAND.maxHeight} };
      const waterMat=new THREE.ShaderMaterial({
        uniforms:waterUniforms, transparent:false, depthWrite:true, fog:true,
        vertexShader:"varying vec2 vUv; varying vec3 vPos; uniform float uTime; void main(){ vUv=uv*50.0; vec3 p=position; float t=(sin((position.x+position.z)*0.002 + uTime*0.6)+sin(position.x*0.008 - uTime*0.4))*0.35; p.y+=t; vPos=(modelMatrix*vec4(p,1.0)).xyz; gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}",
        fragmentShader: TERRAIN_GLSL + "uniform float uTime; uniform vec3 uSunDir; uniform vec3 uDeep, uShallowA, uShallowB; uniform sampler2D uNormalsA, uNormalsB; uniform float uOceanSize; uniform float uMaxH; varying vec2 vUv; varying vec3 vPos; #define saturate(x) clamp(x,0.,1.) float wave(vec2 p){ return sin(p.x*1.5 + uTime*0.6)*0.5 + cos(p.y*1.1 - uTime*0.4)*0.5; } void main(){ vec2 uv1=vUv*0.6 + vec2(uTime*0.02, -uTime*0.015); vec2 uv2=vUv*1.1 + vec2(-uTime*0.017, uTime*0.013); vec3 n1=texture2D(uNormalsA,uv1).xyz*2.0-1.0; vec3 n2=texture2D(uNormalsB,uv2).xyz*2.0-1.0; vec3 N=normalize(vec3(n1.xy*0.6+n2.xy*0.4,1.0)); vec2 xz=vPos.xz; float h=hFunc(xz); float depth=saturate((0.6*uMaxH - h)/(0.7*uMaxH)); vec3 shallow=mix(uShallowA,uShallowB,saturate(depth*1.2)); vec3 baseCol=mix(shallow,uDeep,smoothstep(0.2,0.85,depth)); vec3 V=normalize(vec3(0.0,1.0,0.0)); float fres=pow(1.0 - saturate(dot(N,V)),3.0); float NdotL=saturate(dot(N, normalize(uSunDir))); float spec=pow(NdotL,64.0)*0.6; float foam=smoothstep(0.02,0.0,depth)*(0.6+0.4*wave(vUv*0.2)); vec3 col=baseCol + vec3(spec) + vec3(1.0)*foam*0.55 + vec3(0.8,0.9,1.0)*fres*0.25; gl_FragColor=vec4(col,1.0); #include <tonemapping_fragment> #include <encodings_fragment> }"
      });
      const waterGeo=new THREE.PlaneBufferGeometry(CONFIG.island.oceanSize, CONFIG.island.oceanSize, 2,2);
      waterGeo.rotateX(-Math.PI/2);
      const water=new THREE.Mesh(waterGeo, waterMat); water.position.y=0.6*ISLAND.maxHeight*0.02; scene.add(water);

      const objectsGroup=new THREE.Group(); scene.add(objectsGroup);

      const matConcrete=new THREE.MeshStandardMaterial({color:0xced3d9,roughness:0.38,metalness:0.05});
      const matGlass=new THREE.MeshPhysicalMaterial({color:0xaad7ff,roughness:0.05,metalness:0.0,transmission:0.7,transparent:true,opacity:0.9});
      const matWood=new THREE.MeshStandardMaterial({color:0x8b6a4f,roughness:0.65,metalness:0.04});
      const matAsphalt=new THREE.MeshStandardMaterial({color:0x3b3d42,roughness:0.85,metalness:0.02});
      const matPier=new THREE.MeshStandardMaterial({color:0x705a43,roughness:0.9});
      const matHeli=new THREE.MeshStandardMaterial({color:0x2c2f36,roughness:0.7});

      function groundY(x,z){ return heightAt(x,z); }

      function addRoadPath(points){
        const curve=new THREE.CatmullRomCurve3(points.map(p=>new THREE.Vector3(p[0], groundY(p[0],p[1])+0.15, p[1])));
        const w=8,segs=200, geo=new THREE.BufferGeometry(); const pos=new Float32Array(segs*6*3); let idx=0;
        for(let i=0;i<segs;i++){ const t0=i/segs, t1=(i+1)/segs; const a=curve.getPoint(t0), b=curve.getPoint(t1); const dir=new THREE.Vector3().subVectors(b,a).normalize(); const left=new THREE.Vector3(-dir.z,0,dir.x); const v0=a.clone().addScaledVector(left,w); const v1=a.clone().addScaledVector(left,-w); const v2=b.clone().addScaledVector(left,-w); const v3=b.clone().addScaledVector(left,w); [v0,v1,v2, v0,v2,v3].forEach(v=>{ pos[idx++]=v.x; pos[idx++]=v.y; pos[idx++]=v.z; }); }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3)); geo.computeVertexNormals(); const mesh=new THREE.Mesh(geo, matAsphalt); objectsGroup.add(mesh);
      }
      addRoadPath([[-600,-400],[-200,0],[180,130],[420,220],[700,150]]);
      addRoadPath([[-700,350],[-450,150],[-200,0],[0,-120],[260,-280],[600,-360]]);

      function addPierWithBoats(){
        const y=groundY(-880,-420)+2;
        const pier=new THREE.Mesh(new THREE.BoxBufferGeometry(200,6,24), matPier);
        pier.position.set(-880,y,-420); objectsGroup.add(pier);
        const boatGeo=new THREE.BoxBufferGeometry(36,8,14); const boatMat=new THREE.MeshStandardMaterial({color:0x2b6cb0,roughness:0.5,metalness:0.2});
        for(let i=0;i<CONFIG.boats;i++){ const b=new THREE.Mesh(boatGeo, boatMat.clone()); b.material.color.offsetHSL(i*0.08,0.05,0.0); b.position.set(-880+40*i-40, y-2, -420-28 - i*20); b.userData.driftPhase=Math.random()*Math.PI*2; objectsGroup.add(b); }
      }
      addPierWithBoats();

      function addHelipad(x=520,z=-160){
        const y=groundY(x,z)+0.8; const pad=new THREE.Mesh(new THREE.CylinderBufferGeometry(50,50,2,64), matHeli); pad.position.set(x,y,z); objectsGroup.add(pad);
        const mark=new THREE.Mesh(new THREE.BoxBufferGeometry(60,0.8,12), new THREE.MeshBasicMaterial({color:0xffffff})); mark.position.set(x,y+1.2,z); objectsGroup.add(mark);
        const mark2=new THREE.Mesh(new THREE.BoxBufferGeometry(12,0.8,50), new THREE.MeshBasicMaterial({color:0xffffff})); mark2.position.set(x,y+1.2,z); objectsGroup.add(mark2);
      }
      addHelipad();

      function addCastle(){
        const s=CONFIG.architecture.castle.size; const baseZ=60; const y=groundY(0,baseZ);
        const group=new THREE.Group();
        const body=new THREE.Mesh(new THREE.BoxBufferGeometry(s[0],s[1],s[2]*1.6), matConcrete); body.position.set(0, y+s[1]*0.5, baseZ); group.add(body);
        const glass=new THREE.Mesh(new THREE.BoxBufferGeometry(s[0]*0.9, s[1]*0.6, 2), matGlass); glass.position.set(0, y+s[1]*0.5, baseZ + s[2]*0.85); group.add(glass);
        const twrGeo=new THREE.CylinderBufferGeometry(4,4, s[1]*1.2, 24);
        for(let i=0;i<8;i++){ const ang=i/8*Math.PI*2; const rx=Math.cos(ang)*(s[0]*0.65); const rz=Math.sin(ang)*(s[2]*0.85); const t=new THREE.Mesh(twrGeo, matConcrete); t.position.set(rx, y+s[1]*0.6, baseZ+rz); group.add(t); }
        objectsGroup.add(group);
      }
      addCastle();

      const vegetationGroup=new THREE.Group(); scene.add(vegetationGroup);
      // Palm: single lowpoly merged into BufferGeometry (no external utils)
      const palmBase=new THREE.Group();
      const trunk=new THREE.Mesh(new THREE.CylinderBufferGeometry(0.8,1.4,18,6), new THREE.MeshStandardMaterial({color:0x7c5a39,roughness:0.85})); trunk.position.y=9; palmBase.add(trunk);
      const leafG=new THREE.PlaneBufferGeometry(16,6,1,1);
      for(let i=0;i<7;i++){ const leaf=new THREE.Mesh(leafG, new THREE.MeshStandardMaterial({color:0x2b8e58, side:THREE.DoubleSide, roughness:0.72})); const a=i/7*Math.PI*2; leaf.position.set(Math.cos(a)*2.2,18,Math.sin(a)*2.2); leaf.lookAt(0,18,0); leaf.rotateX(-0.45); palmBase.add(leaf); }

      function mergedGeometryFrom(object){
        const pos=[],norm=[],uv=[];
        object.traverse(o=>{ if(o.isMesh){ o.updateMatrix(); const og=o.geometry.clone(); og.applyMatrix4(o.matrix);
          const pa=og.attributes.position && Array.from(og.attributes.position.array)||[]; const na=og.attributes.normal && Array.from(og.attributes.normal.array)||[]; const uva=og.attributes.uv && Array.from(og.attributes.uv.array)||[];
          pos.push(pa); norm.push(na); uv.push(uva);
        }});
        const geo=new THREE.BufferGeometry();
        if(pos.length){ const a=new Float32Array([].concat.apply([],pos)); geo.setAttribute('position', new THREE.BufferAttribute(a,3)); }
        if(norm.length){ const a=new Float32Array([].concat.apply([],norm)); geo.setAttribute('normal', new THREE.BufferAttribute(a,3)); }
        if(uv.length){ const a=new Float32Array([].concat.apply([],uv)); geo.setAttribute('uv', new THREE.BufferAttribute(a,2)); }
        return geo;
      }
      const palmGeo=mergedGeometryFrom(palmBase);
      const palmMat=new THREE.MeshStandardMaterial({color:0x2a8a57, roughness:0.75});

      function scatterInstances(count){
        const inst=new THREE.InstancedMesh(palmGeo, palmMat.clone(), count);
        inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        const dummy=new THREE.Object3D(); let i=0,attempts=0;
        while(i<count && attempts<count*10){
          attempts++; const x=-HALF+Math.random()*ISLAND.size; const z=-HALF+Math.random()*ISLAND.size; const h=heightAt(x,z);
          if(h>85) continue; const slope=Math.abs(heightAt(x+2,z)-h)+Math.abs(heightAt(x,z+2)-h); if(slope>1.2) continue;
          const nearBeach=(h<ISLAND.maxHeight*0.18); const r=Math.random(); if( nearBeach ? (r>0.7):(r>0.3) ) continue;
          dummy.position.set(x,h+0.2,z); dummy.scale.setScalar(0.9+Math.random()*0.6); dummy.rotation.y=Math.random()*Math.PI*2; dummy.updateMatrix();
          inst.setMatrixAt(i,dummy.matrix); i++;
        }
        vegetationGroup.add(inst); return inst;
      }
      let palms=null;
      function buildVegetation(q){ const count = q==="high"?480:(q==="low"?220:320); if(palms) vegetationGroup.remove(palms); palms=scatterInstances(count); }

      // Camera controls (no external libs)
      const state={ dragging:false, rotating:false, lastX:0, lastY:0, target:new THREE.Vector3(0,0,0) };
      function updateCameraTarget(dx=0,dz=0){
        state.target.x+=dx; state.target.z+=dz;
        const pad=CONFIG.camera.boundsPad, lim=HALF - pad;
        state.target.x=THREE.MathUtils.clamp(state.target.x, -lim, lim);
        state.target.z=THREE.MathUtils.clamp(state.target.z, -lim, lim);
      }
      function syncCamera(){ center.copy(state.target); placeCamera(); }

      renderer.domElement.addEventListener('mousedown', e=>{ if(e.button===0) state.dragging=true; if(e.button===2) state.rotating=true; state.lastX=e.clientX; state.lastY=e.clientY; });
      window.addEventListener('mouseup', ()=>{ state.dragging=false; state.rotating=false; });
      window.addEventListener('contextmenu', e=>e.preventDefault());
      window.addEventListener('mousemove', e=>{
        const dx=e.clientX-state.lastX, dy=e.clientY-state.lastY; state.lastX=e.clientX; state.lastY=e.clientY;
        if(state.dragging){
          const panSpeed=0.9*(cameraDistance/900); const right=new THREE.Vector3(Math.sin(cameraTheta),0,-Math.cos(cameraTheta)); const fwd=new THREE.Vector3(Math.cos(cameraTheta),0,Math.sin(cameraTheta));
          updateCameraTarget( (-right.x*dx + -fwd.x*dy)*panSpeed, (-right.z*dx + -fwd.z*dy)*panSpeed ); syncCamera();
        } else if(state.rotating){ cameraTheta -= dx*0.005; placeCamera(); }
      });
      renderer.domElement.addEventListener('wheel', e=>{
        e.preventDefault(); const s=Math.exp(-Math.sign(e.deltaY)*0.2);
        cameraDistance=THREE.MathUtils.clamp(cameraDistance*s, CONFIG.camera.minDistance, CONFIG.camera.maxDistance); placeCamera();
        const rect=renderer.domElement.getBoundingClientRect(); const nx=((e.clientX-rect.left)/rect.width)*2-1; const ny=-((e.clientY-rect.top)/rect.height)*2+1;
        updateCameraTarget(nx*8*(1.0-s), -ny*8*(1.0-s)); syncCamera();
      }, {passive:false});

      // Post-processing
      const composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera); composer.addPass(renderPass);
      const fxaa = new THREE.ShaderPass(THREE.FXAAShader);
      const pixelRatio=Math.min(devicePixelRatio,2); fxaa.material.uniforms['resolution'].value.set(1/(innerWidth*pixelRatio), 1/(innerHeight*pixelRatio)); composer.addPass(fxaa);
      const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), CONFIG.post.bloom.intensity, CONFIG.post.bloom.radius, CONFIG.post.bloom.threshold); composer.addPass(bloom);

      // Quality switch
      let QUALITY="auto";
      function setQuality(q){
        QUALITY=q; document.querySelectorAll('.chip').forEach(el=>el.classList.remove('active'));
        const btn=document.querySelector('.chip[data-q="'+q+'"]'); if(btn) btn.classList.add('active');
        terrainGroup.clear(); const seg=q==="high"?CONFIG.island.terrainSegments.high : (q==="low"?CONFIG.island.terrainSegments.low : CONFIG.island.terrainSegments.auto);
        terrainGroup.add(makeTerrainLOD(seg)); buildVegetation(q);
        bloom.strength=q==="high"?1.15:(q==="low"?0.6:0.9);
        renderer.setPixelRatio(q==="high"?Math.min(2,devicePixelRatio):(q==="low"?1.0:Math.min(1.5,devicePixelRatio)));
      }
      document.querySelector('.chip[data-q="auto"]').addEventListener('click', ()=>setQuality('auto'));
      document.querySelector('.chip[data-q="low"]').addEventListener('click', ()=>setQuality('low'));
      document.querySelector('.chip[data-q="high"]').addEventListener('click', ()=>setQuality('high'));
      setQuality('auto');

      // Simple objects
      function addSimpleWorld(){
        // pier & boats already added; add few birds
        const birds=[];
        function makeBird(idx){ const geo=new THREE.BufferGeometry(); const positions=new Float32Array(9); positions.set([-1,0,0, 1,0,0, 0,0.6,0]); geo.setAttribute('position', new THREE.BufferAttribute(positions,3)); const mat=new THREE.MeshBasicMaterial({color:0x2a3a4a}); const tri=new THREE.Mesh(geo,mat); tri.userData={r:180+idx*80,speed:0.05+idx*0.02,h:90+idx*12,phase:Math.random()*Math.PI*2}; scene.add(tri); birds.push(tri); }
        for(let i=0;i<CONFIG.birds;i++) makeBird(i);
        return birds;
      }
      const birds = addSimpleWorld();

      // HUD
      function showToast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=> t.style.display='none',1600); }
      document.getElementById('resetView').addEventListener('click', ()=>{ state.target.set(0,0,0); cameraDistance=CONFIG.camera.startDistance; cameraTheta=THREE.MathUtils.degToRad(CONFIG.camera.thetaDeg); placeCamera(); showToast("Вид сброшен"); });

      // Animate
      let last=performance.now(), accum=0, frames=0, fps=60;
      function animate(now){
        requestAnimationFrame(animate);
        const dt=(now-last)/1000; last=now; accum+=dt; frames++;
        if(accum>0.5){ fps=Math.round(frames/accum); frames=0; accum=0; document.getElementById('fps').textContent="FPS: "+fps; }
        const load=THREE.MathUtils.clamp((1/Math.max(1,fps)) / (1/CONFIG.targetFPS), 0, 1);
        document.getElementById('gpu').textContent="GPU load: "+((load*100)|0)+"%"; document.getElementById('gpuBar').style.width=(Math.round(load*100))+"%";
        // birds
        for(var i=0;i<birds.length;i++){ const b=birds[i]; const u=b.userData; u.phase += u.speed*dt; b.position.set(Math.cos(u.phase)*u.r, u.h + Math.sin(u.phase*2.0)*4.0, Math.sin(u.phase)*u.r); b.lookAt(0,u.h,0); }
        waterUniforms.uTime.value = now*0.001;
        composer.render();
      }
      requestAnimationFrame(animate);

      window.addEventListener('resize', ()=>{
        camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        const pixelRatio=Math.min(devicePixelRatio,2);
        fxaa.material.uniforms['resolution'].value.set(1/(innerWidth*pixelRatio),1/(innerHeight*pixelRatio));
        if(bloom && bloom.setSize) bloom.setSize(innerWidth, innerHeight);
      });

      setTimeout(()=> document.getElementById('hint').classList.add('hide'), 3000);
      log("Scene ready.");
    }catch(err){ log("Init exception:", err && err.message); }
  })();
  </script>
</body>
</html>
