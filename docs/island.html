<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Остров • MiniApp (ocean border, day, top-view)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <style>
    :root { --bg:#0b0f16; --fg:#eae6de; --glass:rgba(255,255,255,.08); --accent:#36c2b6; }
    * { box-sizing: border-box }
    html, body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg); overflow:hidden }
    #app { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }
    #hud { position: fixed; top:10px; left: 50%; transform: translateX(-50%); display:flex; align-items:center; gap:10px; z-index:10; pointer-events:none; }
    .tag { pointer-events:auto; background: rgba(0,0,0,.45); border:1px solid var(--glass); color:var(--fg); padding:6px 10px; border-radius:12px; font-weight:700; backdrop-filter: blur(6px); box-shadow: 0 4px 18px rgba(0,0,0,.35); }
    #legend { pointer-events:auto; position: fixed; right:10px; bottom:10px; z-index:10; background: rgba(0,0,0,.45); border:1px solid var(--glass); border-radius:12px; padding:10px 12px; font-size:12px; }
    #audioBtn { pointer-events:auto; cursor:pointer; border:none; border-radius:12px; padding:8px 12px; font-weight:800; background:linear-gradient(135deg, #eef9f3, #e6faf7); color:#0c0d10; box-shadow:0 8px 22px rgba(0,0,0,.35); }
    #hint { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); z-index:10; font-size:12px; opacity:.7; background: rgba(0,0,0,.4); border:1px solid var(--glass); border-radius:10px; padding:6px 10px; backdrop-filter: blur(6px); }
    #perf { position:fixed; left:10px; bottom:10px; font-size:11px; opacity:.7; background: rgba(0,0,0,.35); border:1px solid var(--glass); padding:6px 10px; border-radius:10px; }
    #err { position: fixed; inset: 10px; background: rgba(0,0,0,.75); border: 1px solid var(--glass); border-radius: 12px; padding: 12px; display:none; z-index: 20; overflow:auto; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/loaders/RGBELoader.js"></script>
</head>
<body>
  <div id="app"><canvas id="c"></canvas></div>
  <div id="hud">
    <div class="tag">JEFFREY EPSTEIN ISLAND · day • ocean border</div>
    <button id="audioBtn" class="tag">Включить звуки</button>
  </div>
  <div id="hint">Управление: ЛКМ — вращение · Колёсико — зум · ПКМ/Shift — панорамирование</div>
  <div id="legend">
    <div><b>Погода:</b> солнечно, день</div>
    <div><b>Камера:</b> вид сверху с небольшим наклоном</div>
  </div>
  <div id="perf">FPS: <span id="fps">—</span></div>
  <div id="err"></div>

  <script>
  (function(){
    const errBox = document.getElementById('err');
    function showErr(msg) { errBox.style.display = 'block'; errBox.textContent = 'Ошибка:\\n' + msg; console.error(msg); }
    window.addEventListener('error', (e)=> showErr(e.message || e.error));
    window.addEventListener('unhandledrejection', (e)=> showErr(e.reason || 'unhandledrejection'));

    try { Telegram?.WebApp?.ready(); Telegram?.WebApp?.expand(); } catch(_) {}

    if (!window.THREE) { showErr('THREE.js не загрузился (CDN)'); return; }

    // === Параметры сцены ===
    const ISLAND_SIZE = 700; // сам остров
    const OCEAN_SIZE  = ISLAND_SIZE * 3; // океан вокруг
    const HALF_I = ISLAND_SIZE/2, HALF_O = OCEAN_SIZE/2;

    const canvas = document.getElementById('c');
    let gl = canvas.getContext('webgl2', { antialias:true, alpha:false });
    if (!gl) gl = canvas.getContext('webgl', { antialias:true, alpha:false });
    if (!gl) { showErr('WebGL не доступен'); return; }

    const renderer = new THREE.WebGLRenderer({ canvas, context: gl, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.setClearColor(0x87bce5, 1); // ясное небо

    const scene = new THREE.Scene();
    // Слегка дымка, но очень слабая, чтобы «солнечно»
    scene.fog = new THREE.FogExp2(0x87bce5, 0.00015);

    const camera = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, 0.5, 30000);

    // --- Встроенный Orbit: вид сверху с небольшим наклоном, долли вдоль направления ---
    const target = new THREE.Vector3(0,0,0);
    const BASE_PHI = THREE.MathUtils.degToRad(58); // фиксируем угол
    let spherical = new THREE.Spherical(HALF_I*1.6, BASE_PHI, THREE.MathUtils.degToRad(35));
    const minDistance = 150, maxDistance = HALF_O*1.3;
    const maxPolar = BASE_PHI, minPolar = BASE_PHI; // фиксируем наклон
    const PAN_MARGIN = 20;
    function clampTargetOcean() {
      target.x = THREE.MathUtils.clamp(target.x, -HALF_O+PAN_MARGIN, HALF_O-PAN_MARGIN);
      target.z = THREE.MathUtils.clamp(target.z, -HALF_O+PAN_MARGIN, HALF_O-PAN_MARGIN);
    }
    function updateCamera(){
      clampTargetOcean();
      spherical.phi = THREE.MathUtils.clamp(spherical.phi, minPolar, maxPolar);
      const sinPhiRadius = spherical.radius * Math.sin(spherical.phi);
      camera.position.set(
        target.x + sinPhiRadius * Math.sin(spherical.theta),
        target.y + spherical.radius * Math.cos(spherical.phi),
        target.z + sinPhiRadius * Math.cos(spherical.theta)
      );
      camera.lookAt(target);
    }
    updateCamera();

    let state = null; // 'ROTATE' | 'PAN'
    let lastX=0, lastY=0;
    const rotateSpeed = 0.005, panSpeed = 0.002, zoomSpeed = 1.0;
    function onDown(e){
      const btn = (e.touches?0:e.button);
      state = (btn===2 || e.shiftKey) ? 'PAN' : 'ROTATE';
      const p = e.touches? e.touches[0] : e;
      lastX = p.clientX; lastY = p.clientY;
      e.preventDefault();
    }
    function onMove(e){
      if (!state) return;
      const p = e.touches? e.touches[0] : e;
      const dx = (p.clientX - lastX), dy = (p.clientY - lastY);
      lastX = p.clientX; lastY = p.clientY;
      if (state==='ROTATE'){
        spherical.theta -= dx * rotateSpeed;
      } else {
        const panX = -dx * panSpeed * (spherical.radius/800);
        const panZ =  dy * panSpeed * (spherical.radius/800);
        const mz = new THREE.Vector3(); camera.getWorldDirection(mz); mz.y=0; mz.normalize();
        const mx = new THREE.Vector3().crossVectors(camera.up, mz).normalize();
        target.addScaledVector(mx, panX).addScaledVector(mz, panZ);
      }
      updateCamera(); e.preventDefault();
    }
    function onUp(){ state = null; }
    function onWheel(e){
      const delta = Math.sign(e.deltaY);
      // «Долли» вдоль взгляда, угол фиксирован
      spherical.radius *= (1 + zoomSpeed * 0.12 * delta);
      spherical.radius = Math.max(minDistance, Math.min(maxDistance, spherical.radius));
      updateCamera(); e.preventDefault();
    }
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    canvas.addEventListener('mouseup', onUp);
    canvas.addEventListener('mouseleave', onUp);
    canvas.addEventListener('wheel', onWheel, {passive:false});
    canvas.addEventListener('touchstart', onDown, {passive:false});
    canvas.addEventListener('touchmove', onMove, {passive:false});
    canvas.addEventListener('touchend', onUp);
    canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

    // Свет: всегда день, ясная погода
    const sun = new THREE.DirectionalLight(0xffffff, 1.25);
    sun.position.set(-1200, 1800, 800); scene.add(sun);
    const hemi = new THREE.HemisphereLight(0xbfd8ff, 0xc1d5e0, 0.75); scene.add(hemi);

    // Лёгкая «солнечная дымка» на горизонте: меняем экспозицию с расстоянием
    function setSunnyDay(){ renderer.toneMappingExposure = 1.05; }
    setSunnyDay();

    // --- Перлин и террейн с биомами ---
    function rand(seed){ const x = Math.sin(seed)*10000; return x - Math.floor(x); }
    function makePerlin(seed){
      const p = new Uint8Array(512);
      for (let i=0;i<256;i++) p[i]=i;
      for (let i=255;i>0;i--){ const j = Math.floor(rand(seed+i)*256); const t=p[i]; p[i]=p[j]; p[j]=t; }
      for (let i=0;i<256;i++) p[256+i]=p[i];
      const grad = (h,x,y)=>{ switch(h&3){ case 0:return x+y; case 1:return -x+y; case 2:return x-y; default:return -x-y; } };
      const fade = (t)=> t*t*t*(t*(t*6-15)+10);
      const lerp = (a,b,t)=> a+(b-a)*t;
      return function(x,y){
        const X = Math.floor(x)&255, Y=Math.floor(y)&255;
        const xf=x-Math.floor(x), yf=y-Math.floor(y);
        const tr = p[p[X+1]+Y+1], tl=p[p[X]+Y+1], br=p[p[X+1]+Y], bl=p[p[X]+Y];
        const u=fade(xf), v=fade(yf);
        const x1=lerp(grad(bl, xf, yf), grad(br, xf-1, yf), u);
        const x2=lerp(grad(tl, xf, yf-1), grad(tr, xf-1, yf-1), u);
        return (lerp(x1, x2, v)+1)/2;
      }
    }
    const perlin = makePerlin(1337);

    function buildTerrain(res, scaleH){
      const geo = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, res, res);
      geo.rotateX(-Math.PI/2);
      const pos = geo.attributes.position;
      const colors = [];
      const v = new THREE.Vector3();
      for (let i=0;i<pos.count;i++){
        v.fromBufferAttribute(pos, i);
        const nx = (v.x + HALF_I)/ISLAND_SIZE;
        const nz = (v.z + HALF_I)/ISLAND_SIZE;
        const h1 = perlin(nx*3.5, nz*3.5), h2=perlin(nx*7.5+100, nz*7.5-30), h3=perlin(nx*15-50, nz*15+50);
        let h = (h1*0.6 + h2*0.3 + h3*0.1);
        const ridge = Math.exp(-Math.pow((nx-0.5)*2.2, 2))*Math.exp(-Math.pow((nz-0.5)*2.2, 2));
        h += ridge*0.38;
        const edge = Math.min(nx, nz, 1-nx, 1-nz);
        let heightM = (h*80) * scaleH;
        if (edge < 0.07) heightM *= 0.45; // пляжи
        pos.setY(i, heightM);

        // Биомы: пляж / равнина / лес / горы (более насыщенные цвета)
        const c = new THREE.Color();
        if (edge < 0.07) c.set('#e5d0a6'); // золотой песок
        else if (heightM > 55) c.set('#585d67'); // базальт
        else {
          const biome = perlin(nx*2+7, nz*2-7);
          if (biome > 0.62) c.set('#1f6b3d'); // густой лес
          else if (biome > 0.45) c.set('#2d7a4f'); // тропики
          else c.set('#9a7b52'); // сухие равнины
        }
        colors.push(c.r,c.g,c.b);
      }
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
      geo.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({ vertexColors:true, metalness:0.05, roughness:0.95 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.frustumCulled = true;
      return mesh;
    }

    const terrainLOD = new THREE.LOD();
    terrainLOD.addLevel(buildTerrain(360, 1.0), 0);
    terrainLOD.addLevel(buildTerrain(200, 1.0), 380);
    terrainLOD.addLevel(buildTerrain(120, 1.0), 780);
    scene.add(terrainLOD);

    // --- Океан: кастомный шейдер вокруг острова ---
    const waterTex = new THREE.TextureLoader().load('assets/waternormals.jpg');
    waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping;
    const waterUniforms = {
      uTime: { value: 0.0 },
      uColor: { value: new THREE.Color('#0d3b66') },
      uNormalMap: { value: waterTex },
      uSunDir: { value: new THREE.Vector3(0.3,1,0.2).normalize() }
    };
    const waterMat = new THREE.ShaderMaterial({
      uniforms: waterUniforms,
      transparent: false,
      vertexShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          vUv = uv * 16.0 + vec2(uTime*0.02, uTime*0.015);
          vec3 pos = position;
          pos.z += sin((position.x + uTime*2.0)*0.03)*0.7;
          pos.x += cos((position.y + uTime*1.6)*0.03)*0.7;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform sampler2D uNormalMap;
        uniform vec3 uSunDir;
        varying vec2 vUv;
        void main(){
          vec3 n = texture2D(uNormalMap, vUv).xyz * 2.0 - 1.0;
          n = normalize(vec3(n.x, n.z, n.y));
          float ndl = clamp(dot(n, normalize(uSunDir)), 0.0, 1.0);
          vec3 col = uColor * (0.62 + 0.38*ndl);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const waterGeom = new THREE.PlaneGeometry(OCEAN_SIZE, OCEAN_SIZE, 160, 160);
    const water = new THREE.Mesh(waterGeom, waterMat);
    water.rotation.x = -Math.PI/2;
    water.position.y = 0.1;
    scene.add(water);

    // --- Вегетация: пальмы, бананы, папоротники, трава ---
    const palmCount = 320;
    const trunkGeo = new THREE.CylinderGeometry(0.22, 0.35, 7.2, 6, 1, false);
    const trunkMat = new THREE.MeshStandardMaterial({ color:'#725532', roughness:0.9 });
    const trunkInst = new THREE.InstancedMesh(trunkGeo, trunkMat, palmCount);
    const leafGeo = new THREE.ConeGeometry(1.3, 2.4, 7);
    const leafMat = new THREE.MeshStandardMaterial({ color:'#216e44', roughness:0.7, metalness:0.0 });
    const leafInst = new THREE.InstancedMesh(leafGeo, leafMat, palmCount*4);

    const bananaCount = 20;
    const bananaTrunk = new THREE.CylinderGeometry(0.18, 0.3, 5.0, 6);
    const bananaLeaf = new THREE.ConeGeometry(1.0, 2.0, 8);
    const bananaTrInst = new THREE.InstancedMesh(bananaTrunk, new THREE.MeshStandardMaterial({color:'#6e5a33'}), bananaCount);
    const bananaLfInst = new THREE.InstancedMesh(bananaLeaf, new THREE.MeshStandardMaterial({color:'#2b8a54'}), bananaCount*3);

    const fernCount = 100;
    const fernGeo = new THREE.ConeGeometry(0.9, 1.0, 7);
    const fernMat = new THREE.MeshStandardMaterial({ color:'#2e7f57', roughness:0.85 });
    const fernInst = new THREE.InstancedMesh(fernGeo, fernMat, fernCount);

    const m4 = new THREE.Matrix4();
    function sampleHeightAt(x, z) {
      const nx = (x + HALF_I)/ISLAND_SIZE, nz = (z + HALF_I)/ISLAND_SIZE;
      const h1 = perlin(nx*3.5, nz*3.5), h2 = perlin(nx*7.5+100, nz*7.5-30), h3 = perlin(nx*15-50, nz*15+50);
      let h = (h1*0.6 + h2*0.3 + h3*0.1);
      const ridge = Math.exp(-Math.pow((nx-0.5)*2.2, 2))*Math.exp(-Math.pow((nz-0.5)*2.2, 2));
      h += ridge*0.38;
      const edge = Math.min(nx, nz, 1-nx, 1-nz);
      let heightM = (h*80);
      if (edge < 0.07) heightM *= 0.45;
      return heightM;
    }

    let leafIndex = 0, bananaLeafIndex = 0;
    for (let i=0; i<palmCount; i++) {
      let x, z;
      for (let tries=0; tries<800; tries++){
        x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
        z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
        const nx = (x + HALF_I)/ISLAND_SIZE, nz=(z+HALF_I)/ISLAND_SIZE;
        const edge = Math.min(nx, nz, 1-nx, 1-nz);
        const nearBeach = edge < 0.12;
        const ok = Math.random() < (nearBeach? 0.7 : 0.3);
        const h = sampleHeightAt(x,z);
        if (ok && h > 1 && h < 48) break;
      }
      const y = sampleHeightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.9, 1.25);
      const rotY = THREE.MathUtils.randFloat(0, Math.PI*2);
      m4.compose(new THREE.Vector3(x, y+3.6*s, z), new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), rotY), new THREE.Vector3(1, s, 1));
      trunkInst.setMatrixAt(i, m4);
      for (let k=0;k<4;k++) {
        const ry = rotY + k*(Math.PI/2) + THREE.MathUtils.randFloat(-0.15,0.15);
        const up = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.6+THREE.MathUtils.randFloat(-0.2,0.2), ry, 0));
        const scale = THREE.MathUtils.randFloat(0.85,1.2);
        m4.compose(new THREE.Vector3(x, y+7.2*s, z), up, new THREE.Vector3(scale, scale, scale));
        leafInst.setMatrixAt(leafIndex++, m4);
      }
    }
    for (let i=0;i<bananaCount;i++){
      const x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.7);
      const z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.7);
      const y = sampleHeightAt(x,z);
      m4.compose(new THREE.Vector3(x, y+2.5, z), new THREE.Quaternion(), new THREE.Vector3(1,1,1));
      bananaTrInst.setMatrixAt(i, m4);
      for (let k=0;k<3;k++){
        const rotY = THREE.MathUtils.randFloat(0, Math.PI*2);
        m4.compose(new THREE.Vector3(x, y+3.5, z), new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.4, rotY, 0)), new THREE.Vector3(1,1,1));
        bananaLfInst.setMatrixAt(bananaLeafIndex++, m4);
      }
    }
    for (let i=0;i<fernCount;i++){
      const x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.8);
      const z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.8);
      const y = sampleHeightAt(x,z);
      m4.compose(new THREE.Vector3(x, y+0.6, z), new THREE.Quaternion(), new THREE.Vector3(1,1,1));
      fernInst.setMatrixAt(i, m4);
    }
    scene.add(trunkInst, leafInst, bananaTrInst, bananaLfInst, fernInst);

    // --- Дороги (простые полосы), пирс, лодки, вертоплощадка ---
    function makeRoad(x1,z1,x2,z2,width=3,color=0x4b4b4b){
      const len = Math.hypot(x2-x1, z2-z1);
      const geo = new THREE.BoxGeometry(width, 0.2, len);
      const mat = new THREE.MeshStandardMaterial({ color, roughness:0.95, metalness:0.0 });
      const m = new THREE.Mesh(geo, mat);
      m.position.set((x1+x2)/2, sampleHeightAt((x1+x2)/2,(z1+z2)/2)+0.11, (z1+z2)/2);
      m.rotation.y = Math.atan2(x2-x1, z2-z1);
      m.castShadow = false; m.receiveShadow = true;
      scene.add(m);
    }

    // Выберем несколько узлов и соединим
    const hub = new THREE.Vector3(0,0,0);
    const villaSpots = [
      new THREE.Vector3(-180,0,  90),
      new THREE.Vector3( 160,0, 110),
      new THREE.Vector3(-120,0,-130),
      new THREE.Vector3( 140,0,-160),
      new THREE.Vector3(  10,0, 180)
    ];
    villaSpots.forEach(v=> makeRoad(hub.x, hub.z, v.x, v.z, 4, 0x424242));

    // Пирс на южном берегу
    const pierPos = new THREE.Vector3(0,0, HALF_I-40);
    makeRoad(hub.x, hub.z, pierPos.x, pierPos.z, 3.2, 0x3d3d3d);
    const pier = new THREE.Mesh(new THREE.BoxGeometry(10,1,40), new THREE.MeshStandardMaterial({color:'#6b5843', roughness:0.8}));
    pier.position.set(pierPos.x, sampleHeightAt(pierPos.x,pierPos.z)+1, pierPos.z+22);
    scene.add(pier);

    function makeBoat(x,z){
      const g = new THREE.Group();
      const hull = new THREE.Mesh(new THREE.BoxGeometry(6,1.4,12), new THREE.MeshStandardMaterial({ color:'#9a9a9a', metalness:0.2, roughness:0.6 }));
      hull.position.y = 0.8; g.add(hull);
      const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,5,6), new THREE.MeshStandardMaterial({ color:'#dcdcdc' }));
      mast.position.y = 3.5; g.add(mast);
      g.position.set(x, 0.6, z);
      g.userData.baseY = 0.6;
      return g;
    }
    const boats = [
      makeBoat(pier.position.x+12, pier.position.z+18),
      makeBoat(pier.position.x-10, pier.position.z+16),
      makeBoat(pier.position.x+ 2, pier.position.z+26)
    ];
    boats.forEach(b=> scene.add(b));

    // Вертолётная площадка
    const helipad = new THREE.Mesh(new THREE.CylinderGeometry(10,10,1,48), new THREE.MeshStandardMaterial({color:'#d8d8d8', roughness:0.7}));
    const helix = new THREE.Mesh(new THREE.RingGeometry(2,6,48), new THREE.MeshBasicMaterial({color:'#ffffff'}));
    helix.rotation.x = -Math.PI/2; helipad.add(helix);
    const hlabel = new THREE.Mesh(new THREE.PlaneGeometry(4,4), new THREE.MeshBasicMaterial({color:'#ffffff'}));
    hlabel.rotation.x = -Math.PI/2; hlabel.position.y = 0.6; helipad.add(hlabel);
    helipad.position.set(-HALF_I*0.55, sampleHeightAt(-HALF_I*0.55, -HALF_I*0.2)+1, -HALF_I*0.2);
    scene.add(helipad);

    // --- Архитектура: замок, виллы и бунгало ---
    function buildCastle(){
      const group = new THREE.Group();
      const baseMat = new THREE.MeshStandardMaterial({ color:'#8a8f96', metalness:0.15, roughness:0.45 });
      const glassMat = new THREE.MeshPhysicalMaterial({ color:'#aee6ff', metalness:0.0, roughness:0.15, transmission:0.0 });
      const body = new THREE.Mesh(new THREE.BoxGeometry(60, 36, 40), baseMat);
      body.position.y = 18; group.add(body);
      // 8 цилиндрических башен
      const towerMat = new THREE.MeshStandardMaterial({ color:'#7f858d', metalness:0.1, roughness:0.5 });
      const r = 35;
      for (let i=0;i<8;i++){
        const ang = i * Math.PI/4;
        const tx = Math.cos(ang)*r, tz = Math.sin(ang)*r;
        const tower = new THREE.Mesh(new THREE.CylinderGeometry(6,6,30,12), towerMat);
        tower.position.set(tx, 15, tz);
        group.add(tower);
      }
      // стеклянные элементы
      const glass = new THREE.Mesh(new THREE.BoxGeometry(40, 10, 4), glassMat);
      glass.position.set(0, 28, 22); group.add(glass);

      // «дымоходы» и частицы
      const chimneys = [];
      for (let i=0;i<3;i++){
        const ch = new THREE.Mesh(new THREE.CylinderGeometry(1,1,6,8), new THREE.MeshStandardMaterial({color:'#6e6e6e'}));
        ch.position.set(-10 + i*10, 21, 0);
        chimneys.push(ch); group.add(ch);
      }
      group.userData.chimneys = chimneys;

      group.position.set(0, sampleHeightAt(0,0), 0);
      scene.add(group);
      return group;
    }
    const castle = buildCastle();

    function makeModernVilla(pos){
      const mat = new THREE.MeshStandardMaterial({ color:'#d0d3d6', metalness:0.05, roughness:0.6 });
      const g = new THREE.Group();
      const b1 = new THREE.Mesh(new THREE.BoxGeometry(18, 8, 12), mat); b1.position.y = 4; g.add(b1);
      const b2 = new THREE.Mesh(new THREE.BoxGeometry(14, 6, 10), new THREE.MeshStandardMaterial({color:'#b8bcc2', roughness:0.55}));
      b2.position.set(0, 10, -2); g.add(b2);
      g.position.set(pos.x, sampleHeightAt(pos.x,pos.z), pos.z);
      scene.add(g);
    }
    function makeBungalow(pos){
      const mat = new THREE.MeshStandardMaterial({ color:'#8a6a4a', roughness:0.9 });
      const g = new THREE.Group();
      const base = new THREE.Mesh(new THREE.BoxGeometry(10, 4, 10), mat); base.position.y = 2; g.add(base);
      const roof = new THREE.Mesh(new THREE.ConeGeometry(7, 4, 6), new THREE.MeshStandardMaterial({ color:'#7a5a3a', roughness:0.9 }));
      roof.position.y = 6; g.add(roof);
      g.position.set(pos.x, sampleHeightAt(pos.x,pos.z), pos.z);
      scene.add(g);
    }

    // 5 вилл
    [-180, 160, -120, 140, 10].forEach((vx,i)=> makeModernVilla(new THREE.Vector3(vx,0, [90,110,-130,-160,180][i])));
    // 7 бунгало
    const bunPos = [
      new THREE.Vector3(-220,0, 40), new THREE.Vector3(220,0,  60), new THREE.Vector3(-200,0,-60),
      new THREE.Vector3(190,0,-80), new THREE.Vector3(-60,0,220), new THREE.Vector3(60,0, 210),
      new THREE.Vector3(0,0,-210)
    ];
    bunPos.forEach(makeBungalow);

    // --- Птицы (5 групп) ---
    const birdGroups = [];
    function makeBirdGroup(radius, height, speed, count, color=0xffffff){
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(count*3);
      for (let i=0;i<count;i++){ positions[i*3+0]=0; positions[i*3+1]=0; positions[i*3+2]=0; }
      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const mat = new THREE.PointsMaterial({ color, size: 2, sizeAttenuation: true });
      const pts = new THREE.Points(geom, mat);
      pts.userData = { radius, height, speed, phase: Math.random()*Math.PI*2 };
      birdGroups.push(pts); scene.add(pts);
    }
    makeBirdGroup(160, 140, 0.4, 60, 0xffffff);
    makeBirdGroup(220, 180, 0.32, 80, 0xfff3bf);
    makeBirdGroup(120, 160, 0.5, 50, 0xe3fafc);
    makeBirdGroup(260, 200, 0.28, 70, 0xf1f3f5);
    makeBirdGroup(190, 150, 0.36, 70, 0xffffff);

    // --- Аудио морской бриз ---
    let audioReady = false, audioCtx, gainMaster;
    const audioBtn = document.getElementById('audioBtn');
    audioBtn.addEventListener('click', () => {
      if (audioReady) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        gainMaster = audioCtx.createGain(); gainMaster.gain.value = 0.18; gainMaster.connect(audioCtx.destination);
        const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.5;
        const noise = audioCtx.createBufferSource(); noise.buffer = buffer; noise.loop = true;
        const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 500; lp.Q.value = 0.6;
        noise.connect(lp); lp.connect(gainMaster); noise.start();
        audioReady = true; audioBtn.textContent = 'Звуки включены'; audioBtn.disabled = true;
      } catch(e) { showErr('Audio init failed: ' + e); }
    });

    // --- Resize & Loop ---
    function onResize(){
      const dpr = Math.min(2, window.devicePixelRatio||1);
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setPixelRatio(dpr); renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    const fpsEl = document.getElementById('fps');
    let lastTime = performance.now(), frames = 0, t = 0;
    function loop(){
      t += 0.016;
      waterUniforms.uTime.value = t;
      // покачивание лодок
      boats.forEach((b,i)=> b.position.y = 0.6 + Math.sin(t*1.2 + i)*0.15);
      // дым из труб замка
      if (castle && castle.userData && castle.userData.chimneys){
        castle.userData.chimneys.forEach((ch, idx)=>{
          const f = (t*0.6 + idx) % (Math.PI*2);
          ch.position.y = 21 + Math.sin(f)*0.2;
        });
      }
      // птицы (круги)
      birdGroups.forEach(g=>{
        const u = g.userData; const ang = t*u.speed + u.phase;
        g.position.set(Math.cos(ang)*u.radius, u.height, Math.sin(ang)*u.radius);
      });
      renderer.render(scene, camera);
      frames++; const now = performance.now();
      if (now - lastTime > 500) { fpsEl.textContent = Math.round(1000*frames/(now-lastTime)); frames = 0; lastTime = now; }
      requestAnimationFrame(loop);
    }
    onResize(); loop();

    try { Telegram.WebApp.onEvent('backButtonClicked', () => Telegram.WebApp.close()); Telegram.WebApp.BackButton.show(); } catch(_) {}
  })();
  </script>
</body>
</html>
