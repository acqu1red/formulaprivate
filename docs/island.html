<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Остров • MiniApp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  
  <style>
    :root { 
      --bg: #0b0f16; 
      --fg: #eae6de; 
      --glass: rgba(255,255,255,.08);
      --accent: #36c2b6;
      --ocean: #0d3b66;
      --sand: #f5e3be;
      --forest: #2a8a57;
      --jungle: #71c47f;
      --rock: #5e6673;
    }
    
    * { box-sizing: border-box }
    html, body { 
      height: 100%; 
      margin: 0; 
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
      background: var(--bg); 
      color: var(--fg); 
      overflow: hidden;
    }
    
    #app { position: fixed; inset: 0; }
    canvas { display: block; width: 100%; height: 100%; }
    
    #hud {
      position: fixed; 
      top: 10px; 
      left: 50%; 
      transform: translateX(-50%);
      display: flex; 
      align-items: center; 
      gap: 10px; 
      z-index: 10; 
      pointer-events: none;
    }
    
    .tag {
      pointer-events: auto;
      background: rgba(0,0,0,.45); 
      border: 1px solid var(--glass); 
      color: var(--fg);
      padding: 6px 10px; 
      border-radius: 12px; 
      font-weight: 700; 
      backdrop-filter: blur(6px);
      box-shadow: 0 4px 18px rgba(0,0,0,.35);
      transition: all 0.3s ease;
    }
    
    .tag:hover {
      background: rgba(0,0,0,.6);
      transform: translateY(-1px);
    }
    
    #legend { 
      pointer-events: auto; 
      position: fixed; 
      right: 10px; 
      bottom: 10px; 
      z-index: 10;
      background: rgba(0,0,0,.45); 
      border: 1px solid var(--glass); 
      border-radius: 12px; 
      padding: 10px 12px; 
      font-size: 12px;
      backdrop-filter: blur(6px);
    }
    
    #audioBtn {
      pointer-events: auto; 
      cursor: pointer; 
      border: none; 
      border-radius: 12px; 
      padding: 8px 12px; 
      font-weight: 800;
      background: linear-gradient(135deg, #eef9f3, #e6faf7); 
      color: #0c0d10; 
      box-shadow: 0 8px 22px rgba(0,0,0,.35);
      transition: all 0.3s ease;
    }
    
    #audioBtn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 28px rgba(0,0,0,.4);
    }
    
    #audioBtn.playing {
      background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
      color: white;
    }
    
    #hint {
      position: fixed; 
      bottom: 12px; 
      left: 50%; 
      transform: translateX(-50%); 
      z-index: 10;
      font-size: 12px; 
      opacity: .7; 
      background: rgba(0,0,0,.4); 
      border: 1px solid var(--glass); 
      border-radius: 10px; 
      padding: 6px 10px; 
      backdrop-filter: blur(6px);
    }
    
    #perf {
      position: fixed; 
      left: 10px; 
      bottom: 10px; 
      font-size: 11px; 
      opacity: .7;
      background: rgba(0,0,0,.35); 
      border: 1px solid var(--glass); 
      padding: 6px 10px; 
      border-radius: 10px;
    }
    
    #loading {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      font-size: 18px;
      font-weight: 600;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--glass);
      border-top: 3px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 15px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
  
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>

<body>
  <div id="loading">
    <div class="loading-spinner"></div>
    Загрузка острова...
  </div>
  
  <div id="app"><canvas id="c"></canvas></div>
  
  <div id="hud">
    <div class="tag">JEFFREY EPSTEIN ISLAND · 1 км²</div>
    <button id="audioBtn" class="tag">Включить звуки</button>
  </div>
  
  <div id="hint">Управление: ЛКМ — вращение · Колёсико — зум · ПКМ/Shift — панорамирование</div>
  <div id="legend">
    <div><b>Время суток:</b> авто по системному</div>
    <div><b>FPS target:</b> 60 · <b>WebGL:</b> v2→v1 fallback</div>
    <div><b>Water:</b> Ocean.js → Water2 fallback</div>
  </div>
  <div id="perf">FPS: <span id="fps">—</span></div>

  <script type="module">
    // Импорты Three.js
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { FXAAShader } from 'https://unpkg.com/three@0.152.2/examples/jsm/shaders/FXAAShader.js';

    // Telegram WebApp
    const tg = window.Telegram?.WebApp;
    if (tg) {
      tg.ready();
      tg.expand();
    }

    // Audio system
    let audioContext = null;
    let oceanSound = null;
    let breezeSound = null;
    let isAudioEnabled = false;
    
    const audioBtn = document.getElementById('audioBtn');
    
    function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Ocean waves sound
        const oceanOsc = audioContext.createOscillator();
        const oceanGain = audioContext.createGain();
        const oceanFilter = audioContext.createBiquadFilter();
        
        oceanOsc.type = 'sine';
        oceanOsc.frequency.setValueAtTime(0.1, audioContext.currentTime);
        oceanFilter.type = 'lowpass';
        oceanFilter.frequency.setValueAtTime(200, audioContext.currentTime);
        oceanGain.gain.setValueAtTime(0.3, audioContext.currentTime);
        
        oceanOsc.connect(oceanFilter);
        oceanFilter.connect(oceanGain);
        oceanGain.connect(audioContext.destination);
        
        oceanSound = { osc: oceanOsc, gain: oceanGain, filter: oceanFilter };
        
        // Breeze sound
        const breezeOsc = audioContext.createOscillator();
        const breezeGain = audioContext.createGain();
        const breezeFilter = audioContext.createBiquadFilter();
        
        breezeOsc.type = 'sine';
        breezeOsc.frequency.setValueAtTime(800, audioContext.currentTime);
        breezeFilter.type = 'highpass';
        breezeFilter.frequency.setValueAtTime(600, audioContext.currentTime);
        breezeGain.gain.setValueAtTime(0.1, audioContext.currentTime);
        
        breezeOsc.connect(breezeFilter);
        breezeFilter.connect(breezeGain);
        breezeGain.connect(audioContext.destination);
        
        breezeSound = { osc: breezeOsc, gain: breezeGain, filter: breezeFilter };
        
      } catch (error) {
        console.warn('Audio not supported:', error);
      }
    }
    
    function toggleAudio() {
      if (!audioContext) {
        initAudio();
        return;
      }
      
      isAudioEnabled = !isAudioEnabled;
      
      if (isAudioEnabled) {
        audioContext.resume();
        if (oceanSound) oceanSound.osc.start();
        if (breezeSound) breezeSound.osc.start();
        audioBtn.textContent = 'Выключить звуки';
        audioBtn.classList.add('playing');
      } else {
        if (oceanSound) oceanSound.osc.stop();
        if (breezeSound) breezeSound.osc.stop();
        audioBtn.textContent = 'Включить звуки';
        audioBtn.classList.remove('playing');
      }
    }
    
    audioBtn.addEventListener('click', toggleAudio);

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas: document.getElementById('c'), 
      antialias: true,
      alpha: false 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;

    // Post-processing
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.85);
    composer.addPass(bloomPass);
    
    const fxaaPass = new ShaderPass(FXAAShader);
    fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
    fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
    composer.addPass(fxaaPass);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x404040, 0.8);
    scene.add(hemisphereLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(1000, 1000, 500);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 2000;
    directionalLight.shadow.camera.left = -1000;
    directionalLight.shadow.camera.right = 1000;
    directionalLight.shadow.camera.top = 1000;
    directionalLight.shadow.camera.bottom = -1000;
    scene.add(directionalLight);
    
    // Point lights for atmosphere
    const pointLight1 = new THREE.PointLight(0xff6b6b, 0.8, 300);
    pointLight1.position.set(-200, 50, -200);
    scene.add(pointLight1);
    
    const pointLight2 = new THREE.PointLight(0x4ecdc4, 0.6, 250);
    pointLight2.position.set(200, 40, 200);
    scene.add(pointLight2);

    // Perlin noise for terrain generation
    function makePerlin(seed) {
      const p = new Uint8Array(512);
      for (let i = 0; i < 256; i++) p[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * 256);
        const t = p[i];
        p[i] = p[j];
        p[j] = t;
      }
      for (let i = 0; i < 256; i++) p[256 + i] = p[i];
      
      return function(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        const xf = x - Math.floor(x);
        const yf = y - Math.floor(y);
        
        const tr = p[p[X + 1] + Y + 1];
        const tl = p[p[X] + Y + 1];
        const br = p[p[X + 1] + Y];
        const bl = p[p[X] + Y];
        
        const u = xf * xf * xf * (xf * (xf * 6 - 15) + 10);
        const v = yf * yf * yf * (yf * (yf * 6 - 15) + 10);
        
        const x1 = (tr - br) * u + br;
        const x2 = (tl - bl) * u + bl;
        
        return (x1 - x2) * v + x2;
      };
    }
    
    const perlin = makePerlin(42);
    
    // Build detailed terrain
    function buildTerrain() {
      const geometry = new THREE.PlaneGeometry(1000, 1000, 200, 200);
      geometry.rotateX(-Math.PI / 2);
      
      const positions = geometry.attributes.position;
      const colors = [];
      
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        
        // Multiple noise layers for realistic terrain
        const noise1 = perlin(x * 0.01, z * 0.01) * 100;
        const noise2 = perlin(x * 0.02, z * 0.02) * 50;
        const noise3 = perlin(x * 0.04, z * 0.04) * 25;
        
        let height = noise1 + noise2 + noise3;
        
        // Create island shape
        const distance = Math.sqrt(x * x + z * z);
        const islandRadius = 400;
        if (distance > islandRadius) {
          height *= Math.max(0, 1 - (distance - islandRadius) / 100);
        }
        
        // Beach transition
        const beachStart = 350;
        if (distance > beachStart) {
          const beachFactor = (distance - beachStart) / (islandRadius - beachStart);
          height = height * (1 - beachFactor) + 2 * beachFactor;
        }
        
        positions.setY(i, height);
        
        // Color based on height and position
        let color = new THREE.Color();
        if (distance > beachStart) {
          // Beach
          color.setHex(0xf5e3be);
        } else if (height > 80) {
          // Mountains
          color.setHex(0x5e6673);
        } else if (height > 40) {
          // Forest
          color.setHex(0x2a8a57);
        } else if (height > 20) {
          // Jungle
          color.setHex(0x71c47f);
        } else {
          // Plains
          color.setHex(0xb79b69);
        }
        
        colors.push(color.r, color.g, color.b);
      }
      
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeVertexNormals();
      
      const material = new THREE.MeshStandardMaterial({ 
        vertexColors: true, 
        roughness: 0.8,
        metalness: 0.1
      });
      
      const terrain = new THREE.Mesh(geometry, material);
      terrain.receiveShadow = true;
      terrain.castShadow = true;
      
      return terrain;
    }
    
    const terrain = buildTerrain();
    scene.add(terrain);

    // Realistic water with shader
    const waterGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
    waterGeometry.rotateX(-Math.PI / 2);
    
    const waterMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        waterColor: { value: new THREE.Color(0x0d3b66) },
        foamColor: { value: new THREE.Color(0xffffff) },
        sunDirection: { value: new THREE.Vector3(0.3, 1, 0.2).normalize() }
      },
      vertexShader: `
        uniform float time;
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
          vUv = uv;
          vPosition = position;
          
          vec3 pos = position;
          pos.y += sin((position.x + time * 2.0) * 0.02) * 2.0;
          pos.y += cos((position.z + time * 1.5) * 0.02) * 2.0;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 waterColor;
        uniform vec3 foamColor;
        uniform vec3 sunDirection;
        uniform float time;
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
          vec2 uv = vUv * 20.0 + vec2(time * 0.01, time * 0.008);
          
          float wave1 = sin(uv.x + time * 0.5) * 0.5 + 0.5;
          float wave2 = sin(uv.y + time * 0.3) * 0.5 + 0.5;
          float wave = (wave1 + wave2) * 0.5;
          
          vec3 normal = normalize(vec3(
            sin(uv.x + time * 0.5) * 0.1,
            1.0,
            sin(uv.y + time * 0.3) * 0.1
          ));
          
          float fresnel = pow(1.0 - dot(normal, vec3(0.0, 1.0, 0.0)), 3.0);
          float sunReflection = pow(max(0.0, dot(normal, sunDirection)), 8.0);
          
          vec3 color = mix(waterColor, foamColor, wave * 0.3);
          color = mix(color, vec3(1.0), fresnel * 0.5);
          color = mix(color, vec3(1.0), sunReflection * 0.3);
          
          gl_FragColor = vec4(color, 0.8);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    const water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.position.y = -5;
    scene.add(water);

    // Vegetation system
    function createPalmTree(x, z, height) {
      const group = new THREE.Group();
      
      // Trunk
      const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, height, 8);
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = height / 2;
      trunk.castShadow = true;
      group.add(trunk);
      
      // Leaves
      for (let i = 0; i < 8; i++) {
        const leafGeometry = new THREE.ConeGeometry(0.3, 2, 6);
        const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 });
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        
        const angle = (i / 8) * Math.PI * 2;
        leaf.position.set(
          Math.cos(angle) * 0.5,
          height + 1,
          Math.sin(angle) * 0.5
        );
        leaf.rotation.x = -0.3;
        leaf.rotation.y = angle;
        leaf.castShadow = true;
        group.add(leaf);
      }
      
      group.position.set(x, 0, z);
      return group;
    }
    
    function createBush(x, z) {
      const geometry = new THREE.SphereGeometry(1, 8, 6);
      const material = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });
      const bush = new THREE.Mesh(geometry, material);
      bush.position.set(x, 1, z);
      bush.castShadow = true;
      return bush;
    }
    
    function createRock(x, z, size) {
      const geometry = new THREE.DodecahedronGeometry(size);
      const material = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 });
      const rock = new THREE.Mesh(geometry, material);
      rock.position.set(x, size, z);
      rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      rock.castShadow = true;
      return rock;
    }
    
    function createFlower(x, z) {
      const group = new THREE.Group();
      
      // Stem
      const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
      const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
      const stem = new THREE.Mesh(stemGeometry, stemMaterial);
      stem.position.y = 0.25;
      group.add(stem);
      
      // Flower
      const flowerGeometry = new THREE.SphereGeometry(0.2, 8, 6);
      const flowerMaterial = new THREE.MeshStandardMaterial({ 
        color: Math.random() > 0.5 ? 0xFF69B4 : 0xFFFF00,
        roughness: 0.3
      });
      const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
      flower.position.y = 0.6;
      group.add(flower);
      
      group.position.set(x, 0, z);
      return group;
    }

    // Add vegetation
    for (let i = 0; i < 50; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * 300 + 50;
      const x = Math.cos(angle) * distance;
      const z = Math.sin(angle) * distance;
      
      if (Math.random() > 0.7) {
        const palm = createPalmTree(x, z, 8 + Math.random() * 4);
        scene.add(palm);
      } else if (Math.random() > 0.5) {
        const bush = createBush(x, z);
        scene.add(bush);
      } else {
        const rock = createRock(x, z, 0.5 + Math.random() * 1);
        scene.add(rock);
      }
    }
    
    // Add flowers
    for (let i = 0; i < 100; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * 250 + 30;
      const x = Math.cos(angle) * distance;
      const z = Math.sin(angle) * distance;
      
      const flower = createFlower(x, z);
      scene.add(flower);
    }

    // Buildings
    function createCastle() {
      const group = new THREE.Group();
      
      // Main building
      const mainGeometry = new THREE.BoxGeometry(20, 15, 20);
      const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.8 });
      const main = new THREE.Mesh(mainGeometry, mainMaterial);
      main.position.y = 7.5;
      main.castShadow = true;
      main.receiveShadow = true;
      group.add(main);
      
      // Towers
      for (let i = 0; i < 4; i++) {
        const towerGeometry = new THREE.CylinderGeometry(3, 3, 20, 8);
        const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        
        const angle = (i / 4) * Math.PI * 2;
        tower.position.set(
          Math.cos(angle) * 15,
          10,
          Math.sin(angle) * 15
        );
        tower.castShadow = true;
        group.add(tower);
      }
      
      // Roof
      const roofGeometry = new THREE.ConeGeometry(15, 8, 8);
      const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.7 });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.y = 19;
      roof.castShadow = true;
      group.add(roof);
      
      group.position.set(0, 0, 0);
      return group;
    }
    
    function createVilla(x, z) {
      const group = new THREE.Group();
      
      // House
      const houseGeometry = new THREE.BoxGeometry(8, 6, 8);
      const houseMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.6 });
      const house = new THREE.Mesh(houseGeometry, houseMaterial);
      house.position.y = 3;
      house.castShadow = true;
      house.receiveShadow = true;
      group.add(house);
      
      // Roof
      const roofGeometry = new THREE.ConeGeometry(6, 4, 6);
      const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.y = 8;
      roof.castShadow = true;
      group.add(roof);
      
      group.position.set(x, 0, z);
      return group;
    }
    
    const castle = createCastle();
    scene.add(castle);
    
    // Add villas around the island
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const distance = 150 + Math.random() * 50;
      const x = Math.cos(angle) * distance;
      const z = Math.sin(angle) * distance;
      
      const villa = createVilla(x, z);
      scene.add(villa);
    }

    // Boats
    function createBoat(x, z) {
      const group = new THREE.Group();
      
      // Hull
      const hullGeometry = new THREE.BoxGeometry(4, 1, 8);
      const hullMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
      const hull = new THREE.Mesh(hullGeometry, hullMaterial);
      hull.position.y = 0.5;
      group.add(hull);
      
      // Mast
      const mastGeometry = new THREE.CylinderGeometry(0.2, 0.2, 6);
      const mastMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
      const mast = new THREE.Mesh(mastGeometry, mastMaterial);
      mast.position.y = 3;
      group.add(mast);
      
      // Sail
      const sailGeometry = new THREE.PlaneGeometry(3, 4);
      const sailMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3 });
      const sail = new THREE.Mesh(sailGeometry, sailMaterial);
      sail.position.set(1.5, 2, 0);
      sail.rotation.y = Math.PI / 2;
      group.add(sail);
      
      group.position.set(x, 0, z);
      group.userData = { 
        baseY: 0,
        speed: 0.5 + Math.random() * 0.5,
        direction: Math.random() * Math.PI * 2
      };
      
      return group;
    }
    
    const boats = [];
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = 450 + Math.random() * 100;
      const x = Math.cos(angle) * distance;
      const z = Math.sin(angle) * distance;
      
      const boat = createBoat(x, z);
      boats.push(boat);
      scene.add(boat);
    }

    // Fish
    function createFish() {
      const geometry = new THREE.ConeGeometry(0.3, 1.5, 6);
      const material = new THREE.MeshStandardMaterial({ 
        color: Math.random() > 0.5 ? 0xFF6B6B : 0x4ECDC4,
        roughness: 0.3
      });
      const fish = new THREE.Mesh(geometry, material);
      
      fish.userData = {
        speed: 0.02 + Math.random() * 0.03,
        direction: Math.random() * Math.PI * 2,
        amplitude: 0.5 + Math.random() * 1,
        frequency: 0.01 + Math.random() * 0.02
      };
      
      return fish;
    }
    
    const fish = [];
    for (let i = 0; i < 30; i++) {
      const f = createFish();
      f.position.set(
        (Math.random() - 0.5) * 800,
        -10 - Math.random() * 20,
        (Math.random() - 0.5) * 800
      );
      fish.push(f);
      scene.add(f);
    }

    // Birds
    function createBird() {
      const geometry = new THREE.SphereGeometry(0.2, 6, 6);
      const material = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
      const bird = new THREE.Mesh(geometry, material);
      
      bird.userData = {
        speed: 0.01 + Math.random() * 0.02,
        direction: Math.random() * Math.PI * 2,
        height: 50 + Math.random() * 100,
        radius: 200 + Math.random() * 300
      };
      
      return bird;
    }
    
    const birds = [];
    for (let i = 0; i < 20; i++) {
      const b = createBird();
      const angle = Math.random() * Math.PI * 2;
      const radius = 200 + Math.random() * 300;
      b.position.set(
        Math.cos(angle) * radius,
        50 + Math.random() * 100,
        Math.sin(angle) * radius
      );
      birds.push(b);
      scene.add(b);
    }

    // Camera controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 100;
    controls.maxDistance = 800;
    controls.maxPolarAngle = Math.PI / 2.2; // Limit to top-down view
    controls.minPolarAngle = Math.PI / 3; // Minimum angle
    
    // Set initial camera position
    camera.position.set(0, 400, 400);
    controls.target.set(0, 0, 0);
    controls.update();

    // Animation
    const clock = new THREE.Clock();
    const fpsElement = document.getElementById('fps');
    let frameCount = 0;
    let lastTime = performance.now();
    
    function animate() {
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();
      
      // Update water shader
      waterMaterial.uniforms.time.value = time;
      
      // Animate boats
      boats.forEach(boat => {
        const data = boat.userData;
        data.direction += data.speed * delta;
        
        const radius = 450 + Math.sin(time * 0.1 + boat.id) * 20;
        boat.position.x = Math.cos(data.direction) * radius;
        boat.position.z = Math.sin(data.direction) * radius;
        boat.position.y = data.baseY + Math.sin(time * 2 + boat.id) * 0.5;
        boat.rotation.y = data.direction + Math.PI / 2;
      });
      
      // Animate fish
      fish.forEach(f => {
        const data = f.userData;
        data.direction += data.speed;
        
        f.position.x += Math.cos(data.direction) * 2;
        f.position.z += Math.sin(data.direction) * 2;
        f.position.y = -10 + Math.sin(time * data.frequency + f.id) * data.amplitude;
        
        f.rotation.y = data.direction;
        
        // Wrap around
        if (f.position.x > 400) f.position.x = -400;
        if (f.position.x < -400) f.position.x = 400;
        if (f.position.z > 400) f.position.z = -400;
        if (f.position.z < -400) f.position.z = 400;
      });
      
      // Animate birds
      birds.forEach(bird => {
        const data = bird.userData;
        data.direction += data.speed;
        
        bird.position.x = Math.cos(data.direction) * data.radius;
        bird.position.z = Math.sin(data.direction) * data.radius;
        bird.position.y = data.height + Math.sin(time * 0.5 + bird.id) * 10;
      });
      
      // Update audio
      if (isAudioEnabled && audioContext) {
        if (oceanSound) {
          oceanSound.gain.gain.setValueAtTime(0.3 + Math.sin(time * 0.5) * 0.1, audioContext.currentTime);
        }
        if (breezeSound) {
          breezeSound.gain.gain.setValueAtTime(0.1 + Math.sin(time * 0.3) * 0.05, audioContext.currentTime);
        }
      }
      
      // Update controls
      controls.update();
      
      // Render
      composer.render();
      
      // FPS counter
      frameCount++;
      const currentTime = performance.now();
      if (currentTime - lastTime >= 1000) {
        fpsElement.textContent = Math.round((frameCount * 1000) / (currentTime - lastTime));
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(animate);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      
      fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
      fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
    });

    // Remove loading screen and start animation
    document.getElementById('loading').style.display = 'none';
    animate();
  </script>
</body>
</html>
