<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Остров • MiniApp (water-fallback)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <style>
    :root { --bg:#0b0f16; --fg:#eae6de; --glass:rgba(255,255,255,.08); --accent:#36c2b6; }
    * { box-sizing: border-box }
    html, body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg); overflow:hidden }
    #app { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }
    #hud { position: fixed; top:10px; left: 50%; transform: translateX(-50%); display:flex; align-items:center; gap:10px; z-index:10; pointer-events:none; }
    .tag { pointer-events:auto; background: rgba(0,0,0,.45); border:1px solid var(--glass); color:var(--fg); padding:6px 10px; border-radius:12px; font-weight:700; backdrop-filter: blur(6px); box-shadow: 0 4px 18px rgba(0,0,0,.35); }
    #legend { pointer-events:auto; position: fixed; right:10px; bottom:10px; z-index:10; background: rgba(0,0,0,.45); border:1px solid var(--glass); border-radius:12px; padding:10px 12px; font-size:12px; }
    #audioBtn { pointer-events:auto; cursor:pointer; border:none; border-radius:12px; padding:8px 12px; font-weight:800; background:linear-gradient(135deg, #eef9f3, #e6faf7); color:#0c0d10; box-shadow:0 8px 22px rgba(0,0,0,.35); }
    #hint { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); z-index:10; font-size:12px; opacity:.7; background: rgba(0,0,0,.4); border:1px solid var(--glass); border-radius:10px; padding:6px 10px; backdrop-filter: blur(6px); }
    #perf { position:fixed; left:10px; bottom:10px; font-size:11px; opacity:.7; background: rgba(0,0,0,.35); border:1px solid var(--glass); padding:6px 10px; border-radius:10px; }
    #err { position: fixed; inset: 10px; background: rgba(0,0,0,.75); border: 1px solid var(--glass); border-radius: 12px; padding: 12px; display:none; z-index: 20; overflow:auto; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Only THREE core + minimal extras (no Water.js dependency) -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/loaders/RGBELoader.js"></script>
</head>
<body>
  <div id="app"><canvas id="c"></canvas></div>
  <div id="hud">
    <div class="tag">JEFFREY EPSTEIN ISLAND · 1 км²</div>
    <button id="audioBtn" class="tag">Включить звуки</button>
  </div>
  <div id="hint">Управление: ЛКМ — вращение · Колёсико — зум · ПКМ/Shift — панорамирование</div>
  <div id="legend">
    <div><b>Время суток:</b> авто по системному</div>
    <div><b>WebGL:</b> v2→v1 fallback</div>
    <div><b>Water:</b> custom shader</div>
  </div>
  <div id="perf">FPS: <span id="fps">—</span></div>
  <div id="err"></div>

  <script>
  (function(){
    const errBox = document.getElementById('err');
    function showErr(msg) { errBox.style.display = 'block'; errBox.textContent = 'Ошибка:\\n' + msg; console.error(msg); }
    window.addEventListener('error', (e)=> showErr(e.message || e.error));
    window.addEventListener('unhandledrejection', (e)=> showErr(e.reason || 'unhandledrejection'));

    try { Telegram?.WebApp?.ready(); Telegram?.WebApp?.expand(); } catch(_) {}

    if (!window.THREE) { showErr('THREE.js не загрузился (CDN)'); return; }

    const KM = 1000, ISLAND_SIZE = KM, HALF = ISLAND_SIZE/2;
    const canvas = document.getElementById('c');
    let gl = canvas.getContext('webgl2', { antialias:true, alpha:false });
    if (!gl) gl = canvas.getContext('webgl', { antialias:true, alpha:false });
    if (!gl) { showErr('WebGL не доступен'); return; }

    const renderer = new THREE.WebGLRenderer({ canvas, context: gl, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.setClearColor(0x0b0f16, 1);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b0f16, 0.002);
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.5, 20000);

    // Minimal orbit (no external OrbitControls)
    const target = new THREE.Vector3(0,0,0);
    let spherical = new THREE.Spherical(800, THREE.MathUtils.degToRad(60), THREE.MathUtils.degToRad(45));
    const minDistance = 100, maxDistance = 2000, maxPolar = THREE.MathUtils.degToRad(85);
    function updateCamera(){
      const sinPhiRadius = spherical.radius * Math.sin(spherical.phi);
      camera.position.set(
        target.x + sinPhiRadius * Math.sin(spherical.theta),
        target.y + spherical.radius * Math.cos(spherical.phi),
        target.z + sinPhiRadius * Math.cos(spherical.theta)
      );
      camera.lookAt(target);
    }
    updateCamera();

    let state = null; // 'ROTATE' | 'PAN'
    let lastX=0, lastY=0;
    const rotateSpeed = 0.005, panSpeed = 0.002, zoomSpeed = 1.0;
    function onDown(e){
      const btn = (e.touches?0:e.button);
      state = (btn===2 || e.shiftKey) ? 'PAN' : 'ROTATE';
      const p = e.touches? e.touches[0] : e;
      lastX = p.clientX; lastY = p.clientY;
      e.preventDefault();
    }
    function onMove(e){
      if (!state) return;
      const p = e.touches? e.touches[0] : e;
      const dx = (p.clientX - lastX), dy = (p.clientY - lastY);
      lastX = p.clientX; lastY = p.clientY;
      if (state==='ROTATE'){
        spherical.theta -= dx * rotateSpeed;
        spherical.phi   -= dy * rotateSpeed;
        spherical.phi = Math.max(0.001, Math.min(maxPolar, spherical.phi));
      } else {
        const panX = -dx * panSpeed * (spherical.radius/800);
        const panZ =  dy * panSpeed * (spherical.radius/800);
        const mz = new THREE.Vector3(); camera.getWorldDirection(mz); mz.y=0; mz.normalize();
        const mx = new THREE.Vector3().crossVectors(camera.up, mz).normalize();
        target.addScaledVector(mx, panX).addScaledVector(mz, panZ);
      }
      updateCamera(); e.preventDefault();
    }
    function onUp(){ state = null; }
    function onWheel(e){
      const delta = Math.sign(e.deltaY);
      spherical.radius *= (1 + zoomSpeed * 0.1 * delta);
      spherical.radius = Math.max(minDistance, Math.min(maxDistance, spherical.radius));
      updateCamera(); e.preventDefault();
    }
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('mousemove', onMove);
    canvas.addEventListener('mouseup', onUp);
    canvas.addEventListener('mouseleave', onUp);
    canvas.addEventListener('wheel', onWheel, {passive:false});
    canvas.addEventListener('touchstart', onDown, {passive:false});
    canvas.addEventListener('touchmove', onMove, {passive:false});
    canvas.addEventListener('touchend', onUp);
    canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

    // Env HDR (optional)
    try {
      const pmrem = new THREE.PMREMGenerator(renderer); pmrem.compileEquirectangularShader();
      new THREE.RGBELoader().setDataType(THREE.UnsignedByteType)
        .load('https://rawcdn.githack.com/mrdoob/three.js/r152/examples/textures/equirectangular/venice_sunset_1k.hdr',
          function(tex){ tex.mapping = THREE.EquirectangularReflectionMapping; scene.environment = pmrem.fromEquirectangular(tex).texture; tex.dispose(); },
          undefined, function(){ /* ignore */ });
    } catch(e) {}

    // Lights
    const hour = new Date().getHours();
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(-500, 800, 200); scene.add(sun);
    const hemi = new THREE.HemisphereLight(0x93b6ff, 0x1b2838, 0.35); scene.add(hemi);
    function setupLightingByHour(h) {
      if (h >= 6 && h < 9) { sun.intensity = 0.9; sun.color.set('#ffd9a3'); hemi.intensity = 0.35; renderer.toneMappingExposure = 0.95; }
      else if (h >= 9 && h < 16) { sun.intensity = 1.2; sun.color.set('#ffffff'); hemi.intensity = 0.4; renderer.toneMappingExposure = 1.0; }
      else if (h >= 16 && h < 19) { sun.intensity = 0.85; sun.color.set('#ffb36b'); hemi.intensity = 0.35; renderer.toneMappingExposure = 0.92; }
      else { sun.intensity = 0.25; sun.color.set('#cfdfff'); hemi.intensity = 0.2; renderer.toneMappingExposure = 0.8; }
    }
    setupLightingByHour(hour);

    // Terrain via Perlin (colored by biomes)
    function rand(seed){ const x = Math.sin(seed)*10000; return x - Math.floor(x); }
    function makePerlin(seed){
      const p = new Uint8Array(512);
      for (let i=0;i<256;i++) p[i]=i;
      for (let i=255;i>0;i--){ const j = Math.floor(rand(seed+i)*256); const t=p[i]; p[i]=p[j]; p[j]=t; }
      for (let i=0;i<256;i++) p[256+i]=p[i];
      const grad = (h,x,y)=>{ switch(h&3){ case 0:return x+y; case 1:return -x+y; case 2:return x-y; default:return -x-y; } };
      const fade = (t)=> t*t*t*(t*(t*6-15)+10);
      const lerp = (a,b,t)=> a+(b-a)*t;
      return function(x,y){
        const X = Math.floor(x)&255, Y=Math.floor(y)&255;
        const xf=x-Math.floor(x), yf=y-Math.floor(y);
        const tr = p[p[X+1]+Y+1], tl=p[p[X]+Y+1], br=p[p[X+1]+Y], bl=p[p[X]+Y];
        const u=fade(xf), v=fade(yf);
        const x1=lerp(grad(bl, xf, yf), grad(br, xf-1, yf), u);
        const x2=lerp(grad(tl, xf, yf-1), grad(tr, xf-1, yf-1), u);
        return (lerp(x1, x2, v)+1)/2;
      }
    }
    const perlin = makePerlin(42);

    function buildTerrain(res, scaleH){
      const geo = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, res, res);
      geo.rotateX(-Math.PI/2);
      const pos = geo.attributes.position;
      const colors = [];
      const v = new THREE.Vector3();
      for (let i=0;i<pos.count;i++){
        v.fromBufferAttribute(pos, i);
        const nx = (v.x + HALF)/ISLAND_SIZE;
        const nz = (v.z + HALF)/ISLAND_SIZE;
        const h1 = perlin(nx*4, nz*4), h2=perlin(nx*8+100, nz*8-30), h3=perlin(nx*16-50, nz*16+50);
        let h = (h1*0.6 + h2*0.3 + h3*0.1);
        const ridge = Math.exp(-Math.pow((nx-0.5)*2.4, 2))*Math.exp(-Math.pow((nz-0.5)*2.4, 2));
        h += ridge*0.35;
        const edge = Math.min(nx, nz, 1-nx, 1-nz);
        let heightM = (h*100) * scaleH;
        if (edge < 0.07) heightM *= 0.5;
        pos.setY(i, heightM);

        const c = new THREE.Color();
        if (edge < 0.07) c.set('#cdb896'); // beach
        else if (heightM > 50) c.set('#4b4e57'); // rock
        else { const bN = perlin(nx*2+10, nz*2-10); c.set(bN>0.55 ? '#184a2c' : '#8b6f4a'); } // forest vs plain
        colors.push(c.r,c.g,c.b);
      }
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
      geo.computeVertexNormals();
      const mat = new THREE.MeshStandardMaterial({ vertexColors:true, metalness:0.0, roughness:0.95 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.frustumCulled = true;
      return mesh;
    }

    const terrainLOD = new THREE.LOD();
    terrainLOD.addLevel(buildTerrain(512, 1.0), 0);
    terrainLOD.addLevel(buildTerrain(256, 1.0), 400);
    terrainLOD.addLevel(buildTerrain(128, 1.0), 900);
    scene.add(terrainLOD);

    // Custom water (no Water.js dependency)
    const waterTex = new THREE.TextureLoader().load('assets/waternormals.jpg'); 
    waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping;
    const waterUniforms = {
      uTime: { value: 0.0 },
      uColor: { value: new THREE.Color('#0d3b66') },
      uNormalMap: { value: waterTex },
      uSunDir: { value: new THREE.Vector3(0.3,1,0.2).normalize() }
    };
    const waterMat = new THREE.ShaderMaterial({
      uniforms: waterUniforms,
      transparent: false,
      vertexShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          vUv = uv * 20.0 + vec2(uTime*0.02, uTime*0.015);
          vec3 pos = position;
          // лёгкая синусоида
          pos.z += sin((position.x + uTime*2.0)*0.02)*0.8;
          pos.x += cos((position.y + uTime*1.6)*0.02)*0.8;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform sampler2D uNormalMap;
        uniform vec3 uSunDir;
        varying vec2 vUv;
        void main(){
          vec3 n = texture2D(uNormalMap, vUv).xyz * 2.0 - 1.0;
          n = normalize(vec3(n.x, n.z, n.y));
          float ndl = clamp(dot(n, normalize(uSunDir)), 0.0, 1.0);
          vec3 col = uColor * (0.55 + 0.45*ndl);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const waterGeom = new THREE.PlaneGeometry(ISLAND_SIZE*4, ISLAND_SIZE*4, 256, 256);
    const water = new THREE.Mesh(waterGeom, waterMat);
    water.rotation.x = -Math.PI/2;
    water.position.y = 0.2;
    scene.add(water);

    // Simple vegetation (instanced palms)
    const palmCount = 220;
    const trunkGeo = new THREE.CylinderGeometry(0.25, 0.4, 8, 6, 1, false);
    const trunkMat = new THREE.MeshStandardMaterial({ color:'#6b4f2d', roughness:0.9 });
    const trunkInst = new THREE.InstancedMesh(trunkGeo, trunkMat, palmCount);
    const leafGeo = new THREE.ConeGeometry(1.4, 2.8, 6);
    const leafMat = new THREE.MeshStandardMaterial({ color:'#1f7a4b', roughness:0.7, metalness:0.0 });
    const leafInst = new THREE.InstancedMesh(leafGeo, leafMat, palmCount*4);
    const m4 = new THREE.Matrix4();
    function sampleHeightAt(x, z) {
      const nx = (x + HALF)/ISLAND_SIZE, nz = (z + HALF)/ISLAND_SIZE;
      const h1 = perlin(nx*4, nz*4), h2 = perlin(nx*8+100, nz*8-30), h3 = perlin(nx*16-50, nz*16+50);
      let h = (h1*0.6 + h2*0.3 + h3*0.1);
      const ridge = Math.exp(-Math.pow((nx-0.5)*2.4, 2))*Math.exp(-Math.pow((nz-0.5)*2.4, 2));
      h += ridge*0.35;
      const edge = Math.min(nx, nz, 1-nx, 1-nz);
      let heightM = (h*100);
      if (edge < 0.07) heightM *= 0.5;
      return heightM;
    }
    let leafIndex = 0;
    for (let i=0; i<palmCount; i++) {
      let x, z, nearBeach=false;
      for (let tries=0; tries<1000; tries++){
        x = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
        z = THREE.MathUtils.randFloatSpread(ISLAND_SIZE*0.9);
        const nx = (x + HALF)/ISLAND_SIZE, nz=(z+HALF)/ISLAND_SIZE;
        const edge = Math.min(nx, nz, 1-nx, 1-nz);
        nearBeach = edge < 0.12;
        const ok = Math.random() < (nearBeach? 0.7 : 0.3);
        const h = sampleHeightAt(x,z);
        if (ok && h > 1 && h < 40) break;
      }
      const y = sampleHeightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.9, 1.25);
      const rotY = THREE.MathUtils.randFloat(0, Math.PI*2);
      m4.compose(new THREE.Vector3(x, y+4*s, z), new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), rotY), new THREE.Vector3(1, s, 1));
      trunkInst.setMatrixAt(i, m4);
      for (let k=0;k<4;k++) {
        const ry = rotY + k*(Math.PI/2) + THREE.MathUtils.randFloat(-0.15,0.15);
        const up = new THREE.Quaternion().setFromEuler(new THREE.Euler(-0.6+THREE.MathUtils.randFloat(-0.2,0.2), ry, 0));
        const scale = THREE.MathUtils.randFloat(0.8,1.2);
        m4.compose(new THREE.Vector3(x, y+8.5*s, z), up, new THREE.Vector3(scale, scale, scale));
        leafInst.setMatrixAt(leafIndex++, m4);
      }
    }
    scene.add(trunkInst, leafInst);

    // Clouds (sprite-based)
    const cloudTex = new THREE.TextureLoader().load('assets/cloud.png', function(t){ t.wrapS=t.wrapT=THREE.RepeatWrapping; });
    const cloudGroup = new THREE.Group(); scene.add(cloudGroup);
    for (let i=0;i<12;i++){
      const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: cloudTex, color:0xffffff, opacity: (i%2?0.45:0.35) }));
      sp.position.set(THREE.MathUtils.randFloatSpread(ISLAND_SIZE), 250+THREE.MathUtils.randFloat(-40,60), THREE.MathUtils.randFloatSpread(ISLAND_SIZE));
      sp.scale.setScalar(180 + Math.random()*220);
      cloudGroup.add(sp);
    }

    // Audio toggle
    let audioReady = false, audioCtx, gainMaster;
    const audioBtn = document.getElementById('audioBtn');
    audioBtn.addEventListener('click', () => {
      if (audioReady) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        gainMaster = audioCtx.createGain(); gainMaster.gain.value = 0.2; gainMaster.connect(audioCtx.destination);
        // море (розовый шум)
        const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.6;
        const noise = audioCtx.createBufferSource(); noise.buffer = buffer; noise.loop = true;
        const filter = audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value = 400; filter.Q.value = 0.5;
        noise.connect(filter); filter.connect(gainMaster); noise.start();
        audioReady = true; audioBtn.textContent = 'Звуки включены'; audioBtn.disabled = true;
      } catch(e) { showErr('Audio init failed: ' + e); }
    });

    // Animate
    function onResize(){
      const dpr = Math.min(2, window.devicePixelRatio||1);
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setPixelRatio(dpr); renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    const fpsEl = document.getElementById('fps');
    let lastTime = performance.now(), frames = 0, t = 0;
    function loop(){
      t += 0.016;
      waterUniforms.uTime.value = t;
      renderer.render(scene, camera);
      frames++; const now = performance.now();
      if (now - lastTime > 500) { fpsEl.textContent = Math.round(1000*frames/(now-lastTime)); frames = 0; lastTime = now; }
      requestAnimationFrame(loop);
    }
    onResize(); loop();

    try { Telegram.WebApp.onEvent('backButtonClicked', () => Telegram.WebApp.close()); Telegram.WebApp.BackButton.show(); } catch(_) {}
  })();
  </script>
</body>
</html>
