<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Навигация · Храмы и Книги — MiniApp</title>
  <meta name="color-scheme" content="dark light">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --glass: rgba(255,255,255,.12);
      --ink: #0b1020;
      --fg: #f6f8fb;
      --accent: #36c2b6;
      --accent-soft: #36c2b633;
      --bg: radial-gradient(1200px 800px at 50% 0%, #142236, #0b1422 60%, #08101b);
    }
    html, body { height:100%; margin:0; overflow:hidden; background:#0b1422; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { position:fixed; inset:0; background:var(--bg); }
    canvas { display:block; width:100%; height:100%; }
    /* HUD */
    .hud { position:fixed; left:0; right:0; top:10px; display:flex; justify-content:center; z-index:20; pointer-events:none; }
    .title { pointer-events:auto; background:rgba(0,0,0,.35); backdrop-filter: blur(8px); border:1px solid var(--glass); color:#eaf2ff; padding:8px 14px; border-radius:12px; font-weight:800; box-shadow:0 10px 24px rgba(0,0,0,.35); }
    .subtitle { font-weight:600; opacity:.85; }
    .back { position:fixed; left:12px; bottom:12px; z-index:20; border:none; padding:10px 14px; border-radius:999px; font-weight:800; cursor:pointer; background:linear-gradient(135deg, #f9fafb, #eef2ff); color:#0b1220; box-shadow:0 10px 24px rgba(0,0,0,.35); }
    .back:active { transform: translateY(1px); }
    /* Intro overlay */
    .intro {
      position:fixed; inset:16px; z-index:30; border-radius:16px; padding:18px;
      display:flex; flex-direction:column; gap:16px; color:#0b1220;
      background:linear-gradient(135deg, #e9f7ffcc, #f2fbffcc);
      border:2px solid #ffffffa0; box-shadow:0 30px 70px rgba(0,0,0,.35);
      max-width: 960px; margin: auto;
    }
    .intro h1 { margin:0; font-size:20px; }
    .intro p { margin:0; line-height:1.5; }
    .intro .row { display:flex; gap:10px; justify-content:space-between; align-items:center; }
    .intro .ghost { font-size:12px; opacity:.65; }
    .intro .close { border:none; background:#0b1220; color:#fff; border-radius:10px; padding:8px 12px; cursor:pointer; font-weight:800; }
    .intro .progress {
      height:6px; border-radius:999px; background:#00000022; overflow:hidden; border:1px solid #ffffff88;
    }
    .intro .bar { height:100%; width:0%; background:linear-gradient(90deg, #36c2b6, #87e3db); }
    /* Confirm overlay (suction) */
    .vortex {
      position:fixed; inset:0; pointer-events:none; z-index:25; display:none;
      background: radial-gradient(circle at var(--cx,50%) var(--cy,50%), rgba(255,255,255,.25) 0%, rgba(255,255,255,.12) 8%, rgba(0,0,0,.3) 35%, rgba(0,0,0,.6) 55%, rgba(0,0,0,.9) 80%);
      animation: vortex 800ms ease forwards;
    }
    @keyframes vortex { 0%{ opacity:0 } 10%{ opacity:1 } 100%{ opacity:1 } }
    /* Book overlay */
    .book {
      position:fixed; inset:0; z-index:40; display:none; align-items:center; justify-content:center;
      background: radial-gradient(1200px 800px at 50% 50%, #f6f0e6, #eaddcf);
    }
    .book .paper {
      width:min(780px, 92vw); aspect-ratio: 3/2; border-radius:16px;
      background: linear-gradient(90deg, #fdfaf6 0%, #fff 40%, #fff 60%, #fdfaf6 100%);
      box-shadow: 0 30px 60px rgba(0,0,0,.35), inset 0 0 0 2px #00000010, inset 0 0 0 8px #f5efe6;
      padding:24px 28px; color:#2b2b2b; position:relative; overflow:hidden;
      transform: scale(.92); opacity:0; animation: openBook 400ms ease forwards;
    }
    @keyframes openBook { to { transform: scale(1); opacity:1 } }
    .book h2 { margin:0 0 8px 0; font-size:24px; }
    .book p { margin:6px 0 16px 0; line-height:1.55; font-size:16px; }
    .book .cta {
      position:absolute; left:28px; bottom:24px; display:flex; gap:10px; align-items:center;
    }
    .btn {
      border:none; border-radius:12px; padding:10px 14px; font-weight:800; cursor:pointer;
      background:linear-gradient(135deg,#0b1220,#1d293b); color:#fff; box-shadow:0 10px 24px rgba(0,0,0,.35);
    }
    .btn:active { transform: translateY(1px); }
    .btn.alt { background: linear-gradient(135deg, #36c2b6, #6ce0d6); color:#0b1220; }
    /* Small tooltip style top-left for debug */
    .toast { position:fixed; top:10px; left:10px; font-size:12px; opacity:.0; z-index:50; color:#fff; }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
</head>
<body>
  <div id="app"><canvas id="c"></canvas></div>

  <div class="hud"><div id="title" class="title">Нажми на постройку для выбора темы</div></div>
  <button id="backBtn" class="back" style="display:none">← Назад</button>

  <div id="intro" class="intro" role="dialog" aria-modal="true">
    <div class="row">
      <h1>Режим «Навигация по темам»</h1>
      <button class="close" id="introClose">Закрыть ×</button>
    </div>
    <p>Вы попадаете в интерактивное пространство от первого лица. Перед вами — пять храмов, каждый ведёт к своей тематике. Нажмите на храм, чтобы выбрать тему, затем подтвердите — вы окажетесь в комнате с книжной полкой. Выберите книгу и откройте её, чтобы перейти к посту в канале.</p>
    <ul style="margin:0 0 8px 18px; padding:0; line-height:1.5">
      <li>Тап/клик по храму → выбор темы</li>
      <li>Повторный тап → подтверждение и «вход» в храм</li>
      <li>Внутри — выберите одну из подсвеченных книг</li>
      <li>Кнопка «Назад» внизу возвращает на шаг назад</li>
    </ul>
    <div class="ghost">Окно закроется автоматически</div>
    <div class="progress"><div id="introBar" class="bar"></div></div>
  </div>

  <div id="vortex" class="vortex" aria-hidden="true"></div>

  <div id="book" class="book" aria-hidden="true">
    <div class="paper">
      <h2 id="bookTitle">Пост 1</h2>
      <p id="bookLead">Эта книга открывает доступ к материалу по выбранной теме. Нажмите «Читать», чтобы перейти к посту в канале. Приятного чтения!</p>
      <div class="cta">
        <button id="readBtn" class="btn alt">Читать</button>
        <button id="closeBook" class="btn">Закрыть</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script>
(() => {
  try { Telegram?.WebApp?.ready(); Telegram?.WebApp?.expand(); } catch(e) {}

  const STATE = { TEMPLES:'temples', SHELF:'shelf', BOOK:'book' };
  let state = STATE.TEMPLES;
  const titleEl = document.getElementById('title');
  const backBtn = document.getElementById('backBtn');
  const intro = document.getElementById('intro');
  const introClose = document.getElementById('introClose');
  const introBar = document.getElementById('introBar');
  const vortex = document.getElementById('vortex');
  const bookOverlay = document.getElementById('book');
  const readBtn = document.getElementById('readBtn');
  const closeBook = document.getElementById('closeBook');
  const bookTitle = document.getElementById('bookTitle');

  // Intro auto-close (15s)
  let introT = 0;
  function startIntroTimer(){
    const total = 15000; const started = performance.now();
    function tick(){
      const t = performance.now() - started; introT = t/total; if (introT>1) introT=1;
      introBar.style.width = (introT*100).toFixed(1)+'%';
      if (introT < 1) requestAnimationFrame(tick); else hideIntro();
    }
    requestAnimationFrame(tick);
  }
  function hideIntro(){ intro.style.display = 'none'; }
  introClose.addEventListener('click', hideIntro);
  startIntroTimer();

  // Renderer / Scene
  const canvas = document.getElementById('c');
  let gl = canvas.getContext('webgl2', { antialias:true, alpha:false });
  if (!gl) gl = canvas.getContext('webgl', { antialias:true, alpha:false });

  const renderer = new THREE.WebGLRenderer({ canvas, context: gl, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.05;
  renderer.setClearColor(0x0b1422, 1);

  const scene = new THREE.Scene();

  // Camera: first-person-ish (static height, slight head-bob)
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  const CAM = { baseY: 1.75, radius: 16, theta: 0 };
  function updateCamera(){
    camera.position.set(0, CAM.baseY + Math.sin(clock.getElapsedTime()*1.2)*0.03, CAM.radius);
    camera.lookAt(0, 1.2, -8);
  }

  // Lights
  const sun = new THREE.DirectionalLight(0xffffff, 1.25); sun.position.set(-30, 60, 20);
  const hemi = new THREE.HemisphereLight(0xbcd9ff, 0xe9f2ff, 0.85);
  scene.add(sun, hemi);

  // Ground + details near the player
  const ground = new THREE.Mesh(
    new THREE.CylinderGeometry(60, 60, 0.5, 64),
    new THREE.MeshStandardMaterial({ color: 0x0f263d, roughness: .95, metalness: .02 })
  );
  ground.position.set(0, 0, -10);
  scene.add(ground);

  // Palms (simple stylized, passive sway)
  const palms = new THREE.Group();
  function makePalm(x,z,scale=1){
    const g = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.28, 3.2, 6), new THREE.MeshStandardMaterial({ color: 0x7b5a39, roughness:.9 }));
    trunk.position.y = 1.6; g.add(trunk);
    for (let i=0;i<5;i++){
      const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.4, 8), new THREE.MeshStandardMaterial({ color: 0x2a8a57, roughness:.7 }));
      leaf.position.y = 3.0; leaf.rotation.set(-0.7 + (Math.random()*0.3), i*Math.PI*2/5, 0);
      g.add(leaf);
    }
    g.position.set(x, 0.25, z);
    g.scale.setScalar(scale);
    g.userData.sway = Math.random()*Math.PI*2;
    return g;
  }
  for (let i=0;i<24;i++){
    const a = Math.random()*Math.PI*2;
    const r = 8 + Math.random()*10;
    palms.add(makePalm(Math.cos(a)*r*0.8, -10 + Math.sin(a)*r*0.8, 0.9+Math.random()*0.4));
  }
  scene.add(palms);

  // Temples (5) — slightly different each, with passive glow
  const temples = new THREE.Group(); scene.add(temples);
  const templeData = [];
  function makeTemple(i){
    const g = new THREE.Group();
    const baseColor = new THREE.Color().setHSL(0.55 + i*0.05, 0.15+0.04*i, 0.65 - 0.03*i);
    const mat = new THREE.MeshStandardMaterial({ color: baseColor, roughness:0.45, metalness:0.08, emissive:0x000000 });
    const base = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.2, 2.8), mat); base.position.y = 0.6; g.add(base);
    const body = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.3, 2.6 + i*0.2, 12), mat); body.position.y = 2.0; g.add(body);
    const roof = new THREE.Mesh(new THREE.ConeGeometry(1.6 + i*0.05, 1.0 + i*0.1, 16), mat); roof.position.y = 3.4 + i*0.2; g.add(roof);
    const orb = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshStandardMaterial({ color: 0x36c2b6, emissive: 0x36c2b6, emissiveIntensity: 0.2 }));
    orb.position.y = roof.position.y + 0.6; g.add(orb);
    g.position.set((i-2)*5.2, 0, -12 - Math.abs(i-2)*1.5);
    g.userData = { kind:'temple', index:i, label:`Тема ${i+1}`, mat, orb, baseColor };
    return g;
  }
  for (let i=0;i<5;i++){ const t = makeTemple(i); temples.add(t); templeData.push(t); }

  // Raycaster for interactions
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const CLICK = { x:0, y:0, time:0 };
  let selectedTemple = null;
  let selectedBookIndex = null;

  function setPointer(e){
    const rect = canvas.getBoundingClientRect();
    const x = ( (e.touches? e.touches[0].clientX : e.clientX) - rect.left ) / rect.width;
    const y = ( (e.touches? e.touches[0].clientY : e.clientY) - rect.top ) / rect.height;
    pointer.set(x*2-1, -(y*2-1));
  }

  function pick(meshArray){
    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObjects(meshArray, true);
    return hits[0] || null;
  }

  function onCanvasDown(e){
    setPointer(e);
    CLICK.x = pointer.x; CLICK.y = pointer.y; CLICK.time = performance.now();
  }
  function onCanvasUp(e){
    setPointer(e);
    const dt = performance.now() - CLICK.time;
    const dx = Math.abs(pointer.x - CLICK.x);
    const dy = Math.abs(pointer.y - CLICK.y);
    if (dt < 400 && dx < 0.02 && dy < 0.02) {
      handleTap(e);
    }
  }

  canvas.addEventListener('mousedown', onCanvasDown);
  canvas.addEventListener('mouseup', onCanvasUp);
  canvas.addEventListener('touchstart', onCanvasDown, {passive:false});
  canvas.addEventListener('touchend', onCanvasUp);

  // Shelf / books scene (built on demand)
  const shelfGroup = new THREE.Group(); shelfGroup.visible = false; scene.add(shelfGroup);
  let highlightedBooks = new Set();
  function buildShelf(){
    shelfGroup.clear();
    // Room (simple walls)
    const wallMat = new THREE.MeshStandardMaterial({ color: 0xe7ebf0, roughness:.95, metalness:0 });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(24, 18), new THREE.MeshStandardMaterial({ color: 0xced8e2, roughness:.98 }));
    floor.rotation.x = -Math.PI/2; floor.position.set(0,0,-12); shelfGroup.add(floor);
    const back = new THREE.Mesh(new THREE.PlaneGeometry(24, 10), wallMat); back.position.set(0,5,-21); shelfGroup.add(back);
    const left = new THREE.Mesh(new THREE.PlaneGeometry(18, 10), wallMat); left.position.set(-12,5,-12); left.rotation.y = Math.PI/2; shelfGroup.add(left);
    const right= new THREE.Mesh(new THREE.PlaneGeometry(18, 10), wallMat); right.position.set( 12,5,-12); right.rotation.y = -Math.PI/2; shelfGroup.add(right);

    // Shelf — grid of books
    const rows = 4, cols = 10; const spacingX=2.0, spacingY=1.8; const startX = - (cols-1)*spacingX*0.5, startY = 7.5;
    const bookMeshes = [];
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const w = 0.6 + Math.random()*0.3;
        const h = 1.2 + Math.random()*0.6;
        const d = 0.25 + Math.random()*0.15;
        const color = new THREE.Color().setHSL(0.05 + Math.random()*0.95, 0.4+Math.random()*0.3, 0.55+Math.random()*0.2);
        const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({ color: color, roughness:.8 }));
        m.position.set(startX + c*spacingX, startY - r*spacingY, -20.4);
        m.userData = { kind:'book', title:`Пост ${r*cols+c+1}`, index:r*cols+c };
        bookMeshes.append? bookMeshes.append(m): bookMeshes.push(m);
        shelfGroup.add(m);
      }
    }
    // Pick 5 random highlights
    highlightedBooks = new Set();
    while(highlightedBooks.size < 5){
      highlightedBooks.add(Math.floor(Math.random()*bookMeshes.length));
    }
    bookMeshes.forEach((b,i)=>{
      if (highlightedBooks.has(i)){
        b.material.emissive = new THREE.Color(0xffffee);
        b.material.emissiveIntensity = 0.15;
        b.userData.highlight = true;
      }
    });
    shelfGroup.userData.bookMeshes = bookMeshes;
  }

  function showVortexAt(x,y){
    vortex.style.display = 'block';
    vortex.style.setProperty('--cx', (x*100).toFixed(1)+'%');
    vortex.style.setProperty('--cy', (y*100).toFixed(1)+'%');
    setTimeout(()=> vortex.style.display='none', 820);
  }

  function gotoShelf(screenX=0.5, screenY=0.5){
    showVortexAt(screenX, screenY);
    titleEl.textContent = 'Выберите книгу (подсвечено 5)';
    backBtn.style.display = 'inline-flex';
    temples.visible = false;
    shelfGroup.visible = true;
    selectedTemple = null;
    state = STATE.SHELF;
    if (!shelfGroup.userData.bookMeshes) buildShelf();
  }

  function gotoTemples(){
    titleEl.textContent = 'Нажми на постройку для выбора темы';
    backBtn.style.display = 'none';
    temples.visible = true;
    shelfGroup.visible = false;
    bookOverlay.style.display = 'none';
    selectedBookIndex = null;
    state = STATE.TEMPLES;
  }

  function openBook(title){
    bookTitle.textContent = title || 'Пост';
    bookOverlay.style.display = 'flex';
    state = STATE.BOOK;
    titleEl.textContent = 'Нажмите «Закрыть» или «Читать»';
    backBtn.style.display = 'inline-flex';
  }

  backBtn.addEventListener('click', () => {
    if (state === STATE.BOOK){
      bookOverlay.style.display = 'none';
      state = STATE.SHELF;
      titleEl.textContent = 'Выберите книгу (подсвечено 5)';
    } else if (state === STATE.SHELF){
      gotoTemples();
    }
  });

  closeBook.addEventListener('click', () => {
    bookOverlay.style.display = 'none';
    state = STATE.SHELF;
    titleEl.textContent = 'Выберите книгу (подсвечено 5)';
  });

  readBtn.addEventListener('click', () => {
    const url = 'https://t.me/c/1928787715/128';
    try { Telegram?.WebApp?.openLink(url); } catch(e){ window.open(url, '_blank'); }
  });

  function handleTap(e){
    if (state === STATE.TEMPLES){
      const hit = pick([temples]);
      if (!hit) return;
      // find temple group
      let g = hit.object;
      while (g && g.parent){
        if (g.userData && g.userData.kind === 'temple'){ break; }
        g = g.parent;
      }
      if (!g || !g.userData) return;
      if (selectedTemple && selectedTemple !== g){
        // unselect previous
        selectedTemple.userData.mat.emissiveIntensity = 0.0;
        selectedTemple.children.forEach(ch => { if (ch.material && 'emissive' in ch.material) ch.material.emissiveIntensity = 0.0; });
      }
      if (selectedTemple === g){
        // confirm → go to shelf
        titleEl.textContent = 'Нажми ещё раз для подтверждения выбора';
        const rect = canvas.getBoundingClientRect();
        const x = ( (e.touches? e.changedTouches[0].clientX : e.clientX) - rect.left ) / rect.width;
        const y = ( (e.touches? e.changedTouches[0].clientY : e.clientY) - rect.top ) / rect.height;
        setTimeout(()=> gotoShelf(x,y), 120);
      } else {
        selectedTemple = g;
        titleEl.textContent = 'Нажми ещё раз для подтверждения выбора';
        selectedTemple.userData.mat.emissive = new THREE.Color(0x36c2b6);
        selectedTemple.userData.mat.emissiveIntensity = 0.25;
        selectedTemple.children.forEach(ch => { if (ch.material && 'emissive' in ch.material){ ch.material.emissive = new THREE.Color(0x36c2b6); ch.material.emissiveIntensity = 0.2; } });
      }
    } else if (state === STATE.SHELF){
      const hit = pick([shelfGroup]);
      if (!hit || !hit.object || !hit.object.userData) return;
      const b = hit.object;
      if (!b.userData || b.userData.kind !== 'book') return;
      if (selectedBookIndex === b.userData.index){
        // confirm → open book
        openBook(b.userData.title);
      } else {
        selectedBookIndex = b.userData.index;
        titleEl.textContent = 'Нажми ещё раз для подтверждения выбора';
        // gentle pulse
        if (!b.material.emissive){ b.material.emissive = new THREE.Color(0xffffff); }
        b.material.emissiveIntensity = 0.35;
        setTimeout(()=> { if (state===STATE.SHELF && selectedBookIndex===b.userData.index) b.material.emissiveIntensity = 0.22; }, 320);
      }
    }
  }

  // Animation loop
  const clock = new THREE.Clock();
  function loop(){
    const t = clock.getElapsedTime();
    // sway palms
    palms.children.forEach(p => {
      const f = p.userData.sway;
      p.rotation.z = Math.sin(t*0.6 + f)*0.03;
      p.rotation.x = Math.cos(t*0.5 + f)*0.015;
    });
    // temples passive glow
    templeData.forEach((g,i)=>{
      const k = 0.12 + Math.sin(t*1.2 + i)*0.08;
      if (g.userData.mat) g.userData.mat.emissiveIntensity = (selectedTemple===g ? 0.25 : 0.08 + k);
      if (g.userData.orb) g.userData.orb.material.emissiveIntensity = 0.2 + k*0.6;
    });
    updateCamera();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  function onResize(){
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  // Pointer events for raycaster
  function setPointerFromEvent(ev){
    const rect = canvas.getBoundingClientRect();
    const clientX = (ev.touches? ev.changedTouches[0].clientX : ev.clientX);
    const clientY = (ev.touches? ev.changedTouches[0].clientY : ev.clientY);
    pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -(((clientY - rect.top) / rect.height) * 2 - 1);
  }
  canvas.addEventListener('click', (ev) => setPointerFromEvent(ev));

  loop();
  titleEl.textContent = 'Нажми на постройку для выбора темы';
})();</script>
</body>
</html>
