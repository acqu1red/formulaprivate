#!/usr/bin/env python3
"""
Telegram Bot with Webhook support for Railway deployment
"""

import os
import logging
import requests
import json
import base64
import asyncio
import aiohttp
from datetime import datetime, timedelta
from flask import Flask, request, jsonify
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, CallbackContext, filters
from supabase import create_client, Client

# Email –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ Telegram
def send_email_invitation(email, tariff, subscription_id):
    print(f"üìß Email –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞: {email}, —Ç–∞—Ä–∏—Ñ: {tariff}")
    return True

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '7593794536:AAGSiEJolK1O1H5LMtHxnbygnuhTDoII6qc')
WEBHOOK_URL = os.getenv('WEBHOOK_URL', '')
WEBHOOK_PATH = '/webhook'

# –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã
ADMIN_IDS = [708907063, 7365307696]

# Supabase –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
SUPABASE_URL = os.getenv('SUPABASE_URL', 'https://uhhsrtmmuwoxsdquimaa.supabase.co')
SUPABASE_KEY = os.getenv('SUPABASE_KEY', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVoaHNydG1tdXdveHNkcXVpbWFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2OTMwMzcsImV4cCI6MjA3MDI2OTAzN30.5xxo6g-GEYh4ufTibaAtbgrifPIU_ilzGzolAdmAnm8')
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# LAVA TOP (seller API) –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
LAVA_TOP_API_BASE = os.getenv('LAVA_TOP_API_BASE', 'https://gate.lava.top')
LAVA_TOP_API_KEY = os.getenv('LAVA_TOP_API_KEY', 'whjKvjpi2oqAjTOwfbt0YUkulXCxjU5PWUJDxlQXwOuhOCNSiRq2jSX7Gd2Zihav')
LAVA_OFFER_ID_BASIC = os.getenv('LAVA_OFFER_ID_BASIC', '302ecdcd-1581-45ad-8353-a168f347b8cc')
LAVA_TOP_WEBHOOK_SECRET = os.getenv('LAVA_TOP_WEBHOOK_SECRET', '')

# Telegram –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
PUBLIC_BASE_URL = os.getenv('PUBLIC_BASE_URL', 'https://formulaprivate-productionpaymentuknow.up.railway.app')
PRIVATE_CHANNEL_ID = os.getenv('PRIVATE_CHANNEL_ID', '-1001234567890')
ADMIN_IDS = [int(x.strip()) for x in os.getenv('ADMIN_IDS', '708907063,7365307696').split(',') if x.strip()]

# MiniApp
PAYMENT_MINIAPP_URL = os.getenv('PAYMENT_MINIAPP_URL', 'https://acqu1red.github.io/formulaprivate/')

# –°–æ–∑–¥–∞–µ–º Flask –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è health check
app = Flask(__name__)

# Health check endpoint –¥–ª—è Railway
@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({"status": "healthy", "service": "telegram-bot-webhook"})



# Webhook endpoint –¥–ª—è Telegram
@app.route('/webhook', methods=['GET', 'POST'])
def telegram_webhook():
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç webhook –æ—Ç Telegram"""
    try:
        print("=" * 50)
        print("üì• –ü–û–õ–£–ß–ï–ù WEBHOOK –û–¢ TELEGRAM!")
        print("=" * 50)
        print(f"üìã Headers: {dict(request.headers)}")
        print(f"üìã Method: {request.method}")
        print(f"üìã URL: {request.url}")
        print(f"üìã Content-Type: {request.headers.get('Content-Type')}")
        print(f"üìã User-Agent: {request.headers.get('User-Agent')}")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º GET –∑–∞–ø—Ä–æ—Å—ã (–ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏)
        if request.method == 'GET':
            print("‚úÖ GET –∑–∞–ø—Ä–æ—Å - –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ webhook")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º webhook –ø—Ä–∏ GET –∑–∞–ø—Ä–æ—Å–µ
            try:
                webhook_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getWebhookInfo"
                response = requests.get(webhook_url)
                webhook_data = response.json()
                
                current_url = webhook_data.get('result', {}).get('url', '')
                expected_url = "https://formulaprivate-productionpaymentuknow.up.railway.app/webhook"
                
                if current_url != expected_url:
                    print(f"‚ö†Ô∏è Webhook –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: {current_url} != {expected_url}")
                    print("üîß –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º webhook...")
                    
                    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π webhook
                    delete_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/deleteWebhook"
                    requests.post(delete_url)
                    
                    import time
                    time.sleep(2)
                    
                    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π webhook
                    set_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setWebhook"
                    webhook_data_setup = {
                        "url": expected_url,
                        "secret_token": os.getenv('WEBHOOK_SECRET', 'Telegram_Webhook_Secret_2024_Formula_Bot_7a6b5c'),
                        "max_connections": 40,
                        "allowed_updates": ["message", "callback_query"]
                    }
                    
                    set_response = requests.post(set_url, json=webhook_data_setup)
                    print(f"üîß Webhook –∏—Å–ø—Ä–∞–≤–ª–µ–Ω: {set_response.status_code}")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ webhook: {e}")
            
            return jsonify({
                "status": "ok", 
                "message": "Telegram webhook endpoint –¥–æ—Å—Ç—É–ø–µ–Ω",
                "method": "GET",
                "timestamp": datetime.now().isoformat()
            })
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç Telegram (—Ç–æ–ª—å–∫–æ –¥–ª—è POST)
        print("üì• –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º POST –∑–∞–ø—Ä–æ—Å –æ—Ç Telegram")
        data = request.get_json()
        print(f"üìã –î–∞–Ω–Ω—ã–µ –æ—Ç Telegram: {data}")
        print(f"üìã –†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö: {len(str(data)) if data else 0} —Å–∏–º–≤–æ–ª–æ–≤")
        print(f"üìã Content-Length: {request.headers.get('Content-Length')}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –æ—Ç Telegram
        if not data:
            print("‚ùå –î–∞–Ω–Ω—ã–µ –ø—É—Å—Ç—ã–µ –∏–ª–∏ –Ω–µ JSON")
            return jsonify({"status": "error", "message": "No data"}), 400
        
        if 'update_id' not in data:
            print("‚ùå –≠—Ç–æ –Ω–µ Telegram webhook (–Ω–µ—Ç update_id)")
            return jsonify({"status": "error", "message": "Not a Telegram webhook"}), 400
        
        # –ü–µ—Ä–µ–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –±–æ—Ç–∞
        if hasattr(app, 'telegram_app'):
            print("‚úÖ –ü–µ—Ä–µ–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ telegram_app")
            
            # –°–æ–∑–¥–∞–µ–º Update –æ–±—ä–µ–∫—Ç
            update = Update.de_json(data, app.telegram_app.bot)
            print(f"üìã Update —Å–æ–∑–¥–∞–Ω: {update}")
            print(f"üìã –¢–∏–ø Update: {type(update)}")
            print(f"üìã Update ID: {update.update_id}")
            
            if update.message:
                print(f"üìã –°–æ–æ–±—â–µ–Ω–∏–µ: {update.message.text if update.message.text else '–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞'}")
                print(f"üìã –û—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {update.message.from_user.id}")
                print(f"üìã web_app_data: {getattr(update.message, 'web_app_data', '–ù–ï–¢')}")
            elif update.callback_query:
                print(f"üìã Callback query: {update.callback_query.data}")
                print(f"üìã –û—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {update.callback_query.from_user.id}")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            import threading
            def process_update_async():
                import asyncio
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                try:
                    print("üîÑ –ó–∞–ø—É—Å–∫–∞–µ–º process_update...")
                    loop.run_until_complete(app.telegram_app.process_update(update))
                    print("‚úÖ –î–∞–Ω–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ")
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
                    import traceback
                    print(f"üìã Traceback: {traceback.format_exc()}")
                finally:
                    loop.close()
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            thread = threading.Thread(target=process_update_async)
            thread.start()
            print("‚úÖ –ü–æ—Ç–æ–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—É—â–µ–Ω")
            
        else:
            print("‚ùå telegram_app –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        return jsonify({"status": "ok"})
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ webhook: {e}")
        import traceback
        print(f"üìã Traceback: {traceback.format_exc()}")
        logging.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ webhook: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

# Endpoint –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞
@app.route('/create-invoice', methods=['POST'])
def create_invoice():
    """–°–æ–∑–¥–∞–µ—Ç –∏–Ω–≤–æ–π—Å —á–µ—Ä–µ–∑ Lava Top API"""
    try:
        print("=" * 50)
        print("üì• –ü–û–õ–£–ß–ï–ù –ó–ê–ü–†–û–° –ù–ê –°–û–ó–î–ê–ù–ò–ï –ò–ù–í–û–ô–°–ê!")
        print("=" * 50)
        
        data = request.get_json()
        print(f"üìã –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {data}")
        
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        user_id = data.get('user_id')
        email = data.get('email')
        tariff = data.get('tariff')
        price = data.get('price')
        
        if not all([user_id, email, tariff, price]):
            return jsonify({"status": "error", "message": "Missing required fields"}), 400
        
        print(f"üìã –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å: user_id={user_id}, email={email}, tariff={tariff}, price={price}")
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å —á–µ—Ä–µ–∑ Lava Top API
        payment_url = create_lava_invoice(user_id, email, tariff, price)
        
        if payment_url:
            return jsonify({
                "status": "success",
                "payment_url": payment_url,
                "message": "Invoice created successfully"
            })
        else:
            return jsonify({
                "status": "error",
                "message": "Failed to create invoice"
            }), 500
            
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞: {e}")
        import traceback
        print(f"üìã Traceback: {traceback.format_exc()}")
        return jsonify({"status": "error", "message": str(e)}), 500

# Endpoint –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞ —á–µ—Ä–µ–∑ Mini Apps
@app.route('/api/create-payment', methods=['POST'])
def create_payment_api():
    """API endpoint –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞ –æ—Ç Mini Apps"""
    try:
        print("=" * 50)
        print("üì• –ü–û–õ–£–ß–ï–ù API –ó–ê–ü–†–û–° –ù–ê –°–û–ó–î–ê–ù–ò–ï –ü–õ–ê–¢–ï–ñ–ê!")
        print("=" * 50)
        
        data = request.get_json()
        print(f"üìã –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {data}")
        
        if not data:
            return jsonify({"ok": False, "error": "No data provided"}), 400
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        user_id = data.get('user_id') or data.get('userId')
        email = data.get('email')
        tariff = data.get('tariff')
        price = data.get('price')
        bank = data.get('bank', 'russian')
        
        if not all([user_id, email, tariff, price]):
            return jsonify({
                "ok": False, 
                "error": "Missing required fields",
                "received_data": data
            }), 400
        
        print(f"üìã –°–æ–∑–¥–∞–µ–º –ø–ª–∞—Ç–µ–∂: user_id={user_id}, email={email}, tariff={tariff}, price={price}")
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å —á–µ—Ä–µ–∑ Lava Top Seller API
        payment_url = create_lava_invoice(user_id, email, tariff, price)
        
        if payment_url:
            print(f"‚úÖ –ü–ª–∞—Ç–µ–∂ —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ: {payment_url}")
            return jsonify({
                "ok": True,
                "payment_url": payment_url,
                "message": "Payment created successfully"
            })
        else:
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–ª–∞—Ç–µ–∂")
            return jsonify({
                "ok": False,
                "error": "Failed to create payment"
            }), 500
            
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞: {e}")
        import traceback
        print(f"üìã Traceback: {traceback.format_exc()}")
        return jsonify({"ok": False, "error": str(e)}), 500

# Webhook endpoint –¥–ª—è Lava Top
@app.route('/lava-webhook', methods=['GET', 'POST'])
def lava_webhook():
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç webhook –æ—Ç Lava Top"""
    try:
        print("=" * 50)
        print("üì• –ü–û–õ–£–ß–ï–ù WEBHOOK –û–¢ LAVA TOP!")
        print("=" * 50)
        print(f"üìã Method: {request.method}")
        print(f"üìã URL: {request.url}")
        print(f"üìã Headers: {dict(request.headers)}")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ –≤–µ–±—Ö—É–∫–∞ (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞)
        if LAVA_TOP_WEBHOOK_SECRET:
            signature = request.headers.get('X-Signature')
            if signature:
                # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É HMAC –ø–æ–¥–ø–∏—Å–∏
                print(f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏: {signature}")
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        if request.method == 'GET':
            print("üîç GET –∑–∞–ø—Ä–æ—Å - –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤")
            data = request.args.to_dict()
        elif request.method == 'POST':
            print("üîç POST –∑–∞–ø—Ä–æ—Å - –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ body")
            data = request.get_json()
            if not data:
                data = request.form.to_dict()
        else:
            return jsonify({"status": "error", "message": "Method not allowed"}), 405
        
        print(f"üìã –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {data}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞ (seller API —Ñ–æ—Ä–º–∞—Ç)
        payment_status = data.get('status') or data.get('state')
        order_id = data.get('order_id') or data.get('id')
        amount = data.get('amount')
        currency = data.get('currency')
        email = data.get('email')
        
        print(f"üìã –°—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞: {payment_status}")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç–µ–∂
        if payment_status in ['success', 'paid', 'completed']:
            print("‚úÖ –ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–µ–Ω!")
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏–∑ –≤–µ–±—Ö—É–∫–∞
            # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ email
            user_id = None
            
            if email:
                try:
                    # –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ email
                    result = supabase.table('bot_users').select('telegram_id').eq('email', email).execute()
                    if result.data:
                        user_id = result.data[0]['telegram_id']
                        print(f"‚úÖ –ù–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ email {email}: {user_id}")
                    else:
                        print(f"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å email {email} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ")
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email: {e}")
                    # –ï—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ bot_users –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ email –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
                    if "relation" in str(e).lower() and "does not exist" in str(e).lower():
                        print("‚ö†Ô∏è –¢–∞–±–ª–∏—Ü–∞ 'bot_users' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –°–æ–∑–¥–∞–π—Ç–µ —Ç–∞–±–ª–∏—Ü—É bot_users –≤ Supabase")
                    elif "column" in str(e).lower() and "does not exist" in str(e).lower():
                        print("‚ö†Ô∏è –ö–æ–ª–æ–Ω–∫–∞ 'email' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ bot_users. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–∞–±–ª–∏—Ü—ã")
                    else:
                        print(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
            
            if user_id:
                try:
                    print(f"üì± –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω–≤–∞–π—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
                    
                    # –°–æ–∑–¥–∞–µ–º –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—É—é –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫—É
                    bot_token = TELEGRAM_BOT_TOKEN
                    invite_url = f"https://api.telegram.org/bot{bot_token}/createChatInviteLink"
                    invite_data = {
                        "chat_id": PRIVATE_CHANNEL_ID,
                        "member_limit": 1,
                        "creates_join_request": False
                    }
                    
                    invite_response = requests.post(invite_url, json=invite_data)
                    if invite_response.status_code == 200:
                        invite_result = invite_response.json()
                        invite_link = invite_result['result']['invite_link']
                        
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–Ω–≤–∞–π—Ç–æ–º
                        message_text = f"üéâ –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞!\n\nüîó –í–∞—à–∞ —Å—Å—ã–ª–∫–∞ –¥–ª—è –≤—Ö–æ–¥–∞ –≤ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª:\n{invite_link}"
                        
                        send_message_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                        message_data = {
                            "chat_id": user_id,
                            "text": message_text,
                            "parse_mode": "HTML"
                        }
                        
                        response = requests.post(send_message_url, json=message_data)
                        if response.status_code == 200:
                            print("‚úÖ –ò–Ω–≤–∞–π—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é")
                        else:
                            print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏–Ω–≤–∞–π—Ç–∞: {response.text}")
                    else:
                        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫–∏: {invite_response.text}")
                        
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            else:
                print("‚ùå user_id –Ω–µ –Ω–∞–π–¥–µ–Ω")
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º
                for admin_id in ADMIN_IDS:
                    try:
                        message_text = f"‚ö†Ô∏è –ü–ª–∞—Ç–µ–∂ –ø—Ä–æ—à–µ–ª, –Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω!\n\nüìß Email: {email}\nüí∞ –°—É–º–º–∞: {amount} {currency}\nüÜî Order ID: {order_id}"
                        
                        send_message_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
                        message_data = {
                            "chat_id": admin_id,
                            "text": message_text,
                            "parse_mode": "HTML"
                        }
                        
                        response = requests.post(send_message_url, json=message_data)
                        if response.status_code == 200:
                            print(f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É {admin_id}")
                        else:
                            print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É {admin_id}: {response.text}")
                    except Exception as e:
                        print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É {admin_id}: {e}")
            
            print("‚úÖ –ü–ª–∞—Ç–µ–∂ –æ–±—Ä–∞–±–æ—Ç–∞–Ω —É—Å–ø–µ—à–Ω–æ")
        else:
            print(f"‚ùå –ü–ª–∞—Ç–µ–∂ –Ω–µ –ø—Ä–æ—à–µ–ª: {payment_status}")
        
        return jsonify({"status": "ok"})
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ Lava Top webhook: {e}")
        import traceback
        print(f"üìã Traceback: {traceback.format_exc()}")
        return jsonify({"status": "error", "message": str(e)}), 500

def create_subscription(user_id, email, tariff, amount, currency, order_id, metadata):
    """–°–æ–∑–¥–∞–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
    try:
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏
        tariff_durations = {
            '1month': 30,
            '1_month': 30,
            '3months': 90,
            '6months': 180,
            '12months': 365
        }
        
        duration_days = tariff_durations.get(tariff, 30)
        end_date = datetime.utcnow() + timedelta(days=duration_days)
        
        subscription_data = {
            'user_id': str(user_id),
            'email': email,
            'tariff': tariff,
            'amount': amount,
            'currency': currency,
            'order_id': order_id,
            'start_date': datetime.utcnow().isoformat(),
            'end_date': end_date.isoformat(),
            'status': 'active',
            'metadata': metadata
        }
        
        print(f"üìä –°–æ–∑–¥–∞–µ–º –ø–æ–¥–ø–∏—Å–∫—É: {subscription_data}")
        
        result = supabase.table('subscriptions').insert(subscription_data).execute()
        print(f"‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ —Å–æ–∑–¥–∞–Ω–∞: {result}")
        
        return result.data[0]['id'] if result.data else 'unknown'
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏: {e}")
        return 'error'

# LAVA TOP Seller API —Ñ—É–Ω–∫—Ü–∏–∏
OFFER_MAP = {
    "basic": LAVA_OFFER_ID_BASIC,
    "1_month": LAVA_OFFER_ID_BASIC,  # –ê–ª–∏–∞—Å –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
}

def _method_by(bank: str, currency: str = "RUB") -> str:
    bank = (bank or "russian").lower()
    currency = (currency or "RUB").upper()
    if currency == "RUB":
        return "BANK131"
    return "UNLIMINT"  # –Ω–∞ –±—É–¥—É—â–µ–µ (USD/EUR), –Ω–µ –ª–æ–º–∞—Ç—å —Ç–µ–∫—É—â—É—é –ª–æ–≥–∏–∫—É

async def create_lava_top_invoice(*, email: str, tariff: str, price: int, bank: str, user_id: str = None, currency: str = "RUB") -> str:
    print(f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ LAVA_TOP_API_KEY: {'–£–°–¢–ê–ù–û–í–õ–ï–ù' if LAVA_TOP_API_KEY else '–ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù'}")
    if LAVA_TOP_API_KEY:
        print(f"üîç –ü—Ä–µ—Ñ–∏–∫—Å –∫–ª—é—á–∞: {LAVA_TOP_API_KEY[:10]}...")
    else:
        raise RuntimeError("LAVA_TOP_API_KEY –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è LAVA_TOP_API_KEY –≤ Railway")
    
    # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º tariff –∫ basic
    tariff_normalized = (tariff or "basic").lower()
    if tariff_normalized not in ["basic", "1_month"]:
        tariff_normalized = "basic"
    
    offer_id = OFFER_MAP.get(tariff_normalized)
    if not offer_id:
        raise RuntimeError(f"No offerId for tariff={tariff}")

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ email
    if user_id and email:
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
            existing_user = supabase.table('bot_users').select('id').eq('telegram_id', user_id).execute()
            if not existing_user.data:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user_data = {
                    'telegram_id': user_id,
                    'email': email,
                    'created_at': datetime.utcnow().isoformat()
                }
                supabase.table('bot_users').insert(user_data).execute()
                print(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ –±–∞–∑–µ —Å email {email}")
            else:
                # –û–±–Ω–æ–≤–ª—è–µ–º email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                supabase.table('bot_users').update({'email': email}).eq('telegram_id', user_id).execute()
                print(f"‚úÖ Email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –æ–±–Ω–æ–≤–ª–µ–Ω: {email}")
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            # –ï—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ bot_users –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ email –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
            if "relation" in str(e).lower() and "does not exist" in str(e).lower():
                print("‚ö†Ô∏è –¢–∞–±–ª–∏—Ü–∞ 'bot_users' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –°–æ–∑–¥–∞–π—Ç–µ —Ç–∞–±–ª–∏—Ü—É bot_users –≤ Supabase")
            elif "column" in str(e).lower() and "does not exist" in str(e).lower():
                print("‚ö†Ô∏è –ö–æ–ª–æ–Ω–∫–∞ 'email' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ bot_users. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–∞–±–ª–∏—Ü—ã")
            else:
                print(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")

    url = f"{LAVA_TOP_API_BASE.rstrip('/')}/api/v2/invoice"
    headers = {
        "X-Api-Key": LAVA_TOP_API_KEY,
        "Accept": "application/json",
        "Content-Type": "application/json",
    }
    payload = {
        "email": email,
        "offerId": offer_id,
        "currency": currency,
        "paymentMethod": _method_by(bank, currency),
        "buyerLanguage": "RU"
    }
    
    print(f"üîß –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å LAVA TOP:")
    print(f"   URL: {url}")
    print(f"   Offer ID: {offer_id}")
    print(f"   Payload: {payload}")
    
    async with aiohttp.ClientSession() as s:
        async with s.post(url, headers=headers, json=payload) as r:
            txt = await r.text()
            print(f"üì° LAVA TOP –æ—Ç–≤–µ—Ç: {r.status} - {txt}")
            
            if r.status != 200:
                raise RuntimeError(f"Lava TOP {r.status}: {txt}")
            
            data = json.loads(txt)
            pay_url = next((data.get(k) for k in ("payUrl","invoiceUrl","paymentUrl","url","link") if data.get(k)), None)
            if not pay_url:
                raise RuntimeError(f"No payment URL in response: {data}")
            return pay_url

def create_lava_invoice(user_id, email, tariff, price):
    """–°–æ–∑–¥–∞–µ—Ç –∏–Ω–≤–æ–π—Å —á–µ—Ä–µ–∑ Lava Top API (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    try:
        print(f"üîß –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        print(f"üìã –î–∞–Ω–Ω—ã–µ: email={email}, tariff={tariff}, price={price}")
        
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º tariff –∫ basic
        tariff_normalized = (tariff or "basic").lower()
        if tariff_normalized not in ["basic", "1_month"]:
            tariff_normalized = "basic"
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –≤ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            payment_url = loop.run_until_complete(
                create_lava_top_invoice(
                    email=email, 
                    tariff=tariff_normalized, 
                    price=price, 
                    bank="russian",
                    user_id=str(user_id)
                )
            )
            print(f"‚úÖ –°–æ–∑–¥–∞–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É: {payment_url}")
            return payment_url
        finally:
            loop.close()
            
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞: {e}")
        import traceback
        print(f"üìã Traceback: {traceback.format_exc()}")
        return None

async def create_lava_invoice_async(user_id, email, tariff, price):
    """–°–æ–∑–¥–∞–µ—Ç –∏–Ω–≤–æ–π—Å —á–µ—Ä–µ–∑ Lava Top API (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    try:
        print(f"üîß –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        print(f"üìã –î–∞–Ω–Ω—ã–µ: email={email}, tariff={tariff}, price={price}")
        
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º tariff –∫ basic
        tariff_normalized = (tariff or "basic").lower()
        if tariff_normalized not in ["basic", "1_month"]:
            tariff_normalized = "basic"
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é seller API
        payment_url = await create_lava_top_invoice(
            email=email, 
            tariff=tariff_normalized, 
            price=price, 
            bank="russian",
            user_id=str(user_id)
        )
        
        print(f"‚úÖ –°–æ–∑–¥–∞–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É: {payment_url}")
        return payment_url
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞: {e}")
        import traceback
        print(f"üìã Traceback: {traceback.format_exc()}")
        return None

# –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
async def start(update: Update, context: CallbackContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    user = update.effective_user
    print(f"üöÄ –ö–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.id}")
    print(f"üìã –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.first_name} {user.last_name or ''} (@{user.username or '–±–µ–∑ username'})")
    print(f"üìã ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user.id}")
    
    welcome_text = f"""
üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!

–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª.

üí° <b>–ß—Ç–æ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ:</b>
‚Ä¢ –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç
‚Ä¢ –î–æ—Å—Ç—É–ø –∫ –∑–∞–∫—Ä—ã—Ç–æ–º—É —Å–æ–æ–±—â–µ—Å—Ç–≤—É
‚Ä¢ –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

üí≥ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> 50‚ÇΩ –≤ –º–µ—Å—è—Ü
    """
    
    keyboard = [
        [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="payment_menu")],
        [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–¥—Ä–æ–±–Ω–µ–µ", callback_data="more_info")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(welcome_text, parse_mode='HTML', reply_markup=reply_markup)

async def payment(update: Update, context: CallbackContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /payment"""
    await payment_menu(update, context)

async def more_info(update: Update, context: CallbackContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /more_info"""
    info_text = """
‚ÑπÔ∏è <b>–ü–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</b>

üìã <b>–ß—Ç–æ –≤–∫–ª—é—á–µ–Ω–æ –≤ –ø–æ–¥–ø–∏—Å–∫—É:</b>
‚Ä¢ –î–æ—Å—Ç—É–ø –∫ –∑–∞–∫—Ä—ã—Ç–æ–º—É Telegram –∫–∞–Ω–∞–ª—É
‚Ä¢ –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç
‚Ä¢ –û–±—â–µ–Ω–∏–µ —Å –µ–¥–∏–Ω–æ–º—ã—à–ª–µ–Ω–Ω–∏–∫–∞–º–∏
‚Ä¢ –†–µ–≥—É–ª—è—Ä–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

‚è±Ô∏è <b>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:</b> 1 –º–µ—Å—è—Ü
üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> 50‚ÇΩ

üîí <b>–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:</b>
‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ Lava Top
‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–¥–ª–µ–Ω–∏–µ
‚Ä¢ –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–º–µ–Ω—ã –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è
    """
    
    keyboard = [
        [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", callback_data="payment_menu")],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(info_text, parse_mode='HTML', reply_markup=reply_markup)

async def payment_menu(update: Update, context: CallbackContext):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –º–µ–Ω—é –æ–ø–ª–∞—Ç—ã"""
    text = """
üí≥ <b>–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª:</b>

‚Ä¢ 1 –º–µ—Å—è—Ü - 50‚ÇΩ

–ü–æ–ª—É—á–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ–º—É –∫–æ–Ω—Ç–µ–Ω—Ç—É –∏ —Å–æ–æ–±—â–µ—Å—Ç–≤—É.
    """
    
    keyboard = [
        [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ Mini Apps", web_app={"url": "https://acqu1red.github.io/formulaprivate/payment.html"})],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text(text, parse_mode='HTML', reply_markup=reply_markup)
    else:
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=reply_markup)



async def handle_web_app_data(update: Update, context: CallbackContext):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ—Ç Mini Apps"""
    print("=" * 50)
    print("üöÄ –í–´–ó–í–ê–ù–ê –§–£–ù–ö–¶–ò–Ø handle_web_app_data!")
    print("=" * 50)
    
    user = update.effective_user
    message = update.message
    
    print(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.id} (@{user.username})")
    print(f"üì± –¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è: {type(message)}")
    print(f"üì± –ï—Å—Ç—å web_app_data: {hasattr(message, 'web_app_data')}")
    print(f"üì± –í—Å–µ –∞—Ç—Ä–∏–±—É—Ç—ã —Å–æ–æ–±—â–µ–Ω–∏—è: {dir(message)}")
    
    if hasattr(message, 'web_app_data') and message.web_app_data:
        print(f"üì± web_app_data –æ–±—ä–µ–∫—Ç: {message.web_app_data}")
        print(f"üì± web_app_data.data: {message.web_app_data.data}")
        print(f"üì± web_app_data.data —Ç–∏–ø: {type(message.web_app_data.data)}")
        
        try:
            # –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –æ—Ç Mini Apps
            web_app_data = message.web_app_data.data
            print(f"üì± –ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –æ—Ç Mini Apps: {web_app_data}")
            
            # –ü—Ä–æ–±—É–µ–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∏–∑ base64, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏—Ç—Å—è - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å
            try:
                import base64
                decoded_data = base64.b64decode(web_app_data).decode('utf-8')
                print(f"üì± –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ base64: {decoded_data}")
                payment_data = json.loads(decoded_data)
            except Exception as decode_error:
                # –ï—Å–ª–∏ –Ω–µ base64, –ø—Ä–æ–±—É–µ–º –ø–∞—Ä—Å–∏—Ç—å –∫–∞–∫ –æ–±—ã—á–Ω—ã–π JSON
                print(f"üì± –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è base64: {decode_error}")
                print(f"üì± –ü–∞—Ä—Å–∏–º –∫–∞–∫ –æ–±—ã—á–Ω—ã–π JSON: {web_app_data}")
                payment_data = json.loads(web_app_data)
            
            print(f"üìã –ü–∞—Ä—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {payment_data}")
            print(f"üìã –¢–∏–ø –¥–∞–Ω–Ω—ã—Ö: {type(payment_data)}")
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            await process_payment_data(update, context, payment_data)
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ web_app_data: {e}")
            import traceback
            print(f"üìã Traceback: {traceback.format_exc()}")
            await message.reply_text("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö –æ—Ç Mini Apps")
    else:
        print("‚ùå web_app_data –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—É—Å—Ç–æ–π")
        print(f"üì± –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {message}")
        await message.reply_text("‚ùå –î–∞–Ω–Ω—ã–µ Mini Apps –Ω–µ –ø–æ–ª—É—á–µ–Ω—ã")

async def handle_all_messages(update: Update, context: CallbackContext):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    print("=" * 30)
    print("üì® –í–´–ó–í–ê–ù–ê –§–£–ù–ö–¶–ò–Ø handle_all_messages!")
    print("=" * 30)
    
    user = update.effective_user
    message = update.message
    
    print(f"üì® –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.id}")
    print(f"üìã –¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è: {type(message)}")
    print(f"üìã –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {message.text if hasattr(message, 'text') else '–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞'}")
    print(f"üìã web_app_data: {getattr(message, 'web_app_data', '–ù–ï–¢')}")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –¥–∞–Ω–Ω—ã–º–∏ –æ—Ç Mini Apps
    if hasattr(message, 'web_app_data') and message.web_app_data:
        print(f"üì± –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –æ—Ç Mini Apps")
        await handle_web_app_data(update, context)
        return
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ JSON –¥–∞–Ω–Ω—ã–º–∏ –≤ —Ç–µ–∫—Å—Ç–µ
    if message.text:
        try:
            data = json.loads(message.text)
            if isinstance(data, dict) and ('step' in data or 'email' in data):
                print(f"üì± –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã JSON –¥–∞–Ω–Ω—ã–µ –≤ —Ç–µ–∫—Å—Ç–µ: {data}")
                await process_payment_data(update, context, data)
                return
        except:
            pass
    
    # –û–±—ã—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    await message.reply_text(
        "üëã –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /start –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã —Å –±–æ—Ç–æ–º!"
    )

async def process_payment_data(update: Update, context: CallbackContext, payment_data: dict):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∞ –æ—Ç Mini Apps"""
    user = update.effective_user
    message = update.message
    
    try:
        print(f"üì± –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∞: {payment_data}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö (–ø–æ—à–∞–≥–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–ª–∏ –ø—Ä—è–º–æ–π —Ñ–æ—Ä–º–∞—Ç)
        step = payment_data.get('step')
        print(f"üìã –®–∞–≥ –¥–∞–Ω–Ω—ã—Ö: {step}")
        
        # –ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ–ª–µ step - —ç—Ç–æ –ø–æ—à–∞–≥–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞
        if step:
            if step == 'test_connection':
                print("‚úÖ –¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ!")
                await message.reply_text("‚úÖ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –±–æ—Ç–æ–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!")
                return
                
            elif step == 'email_data':
                email = payment_data.get('email')
                print(f"üìß –ü–æ–ª—É—á–µ–Ω email: {email}")
                await message.reply_text(f"üìß Email –ø–æ–ª—É—á–µ–Ω: {email}")
                return
                
            elif step == 'tariff_data':
                tariff = payment_data.get('tariff')
                price = payment_data.get('price')
                print(f"üí≥ –ü–æ–ª—É—á–µ–Ω tariff: {tariff}, —Ü–µ–Ω–∞: {price}")
                await message.reply_text(f"üí≥ Tariff –ø–æ–ª—É—á–µ–Ω: {tariff}, —Ü–µ–Ω–∞: {price}‚ÇΩ")
                return
                
            elif step == 'payment_method_data':
                payment_method = payment_data.get('paymentMethod')
                bank = payment_data.get('bank')
                bank_name = payment_data.get('bankName', '–ë–∞–Ω–∫ –†–§')
                print(f"üè¶ –ü–æ–ª—É—á–µ–Ω payment method: {payment_method}, –±–∞–Ω–∫: {bank_name}")
                await message.reply_text(f"üè¶ Payment method –ø–æ–ª—É—á–µ–Ω: {payment_method}, –±–∞–Ω–∫: {bank_name}")
                return
                
            elif step == 'user_id_data':
                user_id = payment_data.get('userId')
                print(f"üë§ –ü–æ–ª—É—á–µ–Ω user ID: {user_id}")
                await message.reply_text(f"üë§ User ID –ø–æ–ª—É—á–µ–Ω: {user_id}")
                return
                
            elif step == 'final_data':
                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                email = payment_data.get('email')
                tariff = payment_data.get('tariff')
                price = payment_data.get('price')
                user_id = payment_data.get('userId')
                bank = payment_data.get('bank', 'russian')
                print(f"üéØ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: email={email}, tariff={tariff}, price={price}, user_id={user_id}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –µ—Å—Ç—å
                if not email or not tariff or not price:
                    print("‚ùå –ù–µ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã:")
                    print(f"   email: {email}")
                    print(f"   tariff: {tariff}")
                    print(f"   price: {price}")
                    await message.reply_text("‚ùå –ù–µ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                    return
                
                print("‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã, —Å–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å...")
                
                # –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å —á–µ—Ä–µ–∑ LAVA TOP Seller API
                try:
                    payment_url = await create_lava_top_invoice(
                        email=email,
                        tariff=tariff,
                        price=price,
                        bank=bank,
                        user_id=str(user.id)
                    )
                    
                    if payment_url:
                        print(f"‚úÖ –ò–Ω–≤–æ–π—Å —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ: {payment_url}")
                        
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π –æ–ø–ª–∞—Ç—ã
                        keyboard = [[InlineKeyboardButton("üí≥ –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ", url=payment_url)]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        
                        await message.reply_text(
                            f"üí≥ <b>–û–ø–ª–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∫–∏</b>\n\n"
                            f"‚úÖ –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã:\n"
                            f"üìß Email: {email}\n"
                            f"üí≥ –¢–∞—Ä–∏—Ñ: {tariff}\n"
                            f"üí∞ –°—É–º–º–∞: {price}‚ÇΩ\n\n"
                            f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –æ–ø–ª–∞—Ç–µ:",
                            parse_mode='HTML',
                            reply_markup=reply_markup
                        )
                        print("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
                        return
                    else:
                        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∏–Ω–≤–æ–π—Å")
                        await message.reply_text("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                        return
                        
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞: {e}")
                    await message.reply_text("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                    return
        else:
            # –ü—Ä—è–º–æ–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö (–±–µ–∑ –ø–æ–ª—è step)
            print("üì¶ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä—è–º–æ–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
            email = payment_data.get('email')
            tariff = payment_data.get('tariff')
            price = payment_data.get('price')
            user_id = payment_data.get('userId')
            bank = payment_data.get('bank', 'russian')
            print(f"üéØ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ: email={email}, tariff={tariff}, price={price}, user_id={user_id}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –µ—Å—Ç—å
            if not email or not tariff or not price:
                print("‚ùå –ù–µ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã:")
                print(f"   email: {email}")
                print(f"   tariff: {tariff}")
                print(f"   price: {price}")
                await message.reply_text("‚ùå –ù–µ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                return
            
            print("‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã, —Å–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å...")
            
            # –°–æ–∑–¥–∞–µ–º –∏–Ω–≤–æ–π—Å —á–µ—Ä–µ–∑ LAVA TOP Seller API
            try:
                payment_url = await create_lava_top_invoice(
                    email=email,
                    tariff=tariff,
                    price=price,
                    bank=bank,
                    user_id=str(user.id)
                )
                
                if payment_url:
                    print(f"‚úÖ –ò–Ω–≤–æ–π—Å —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ: {payment_url}")
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π –æ–ø–ª–∞—Ç—ã
                    keyboard = [[InlineKeyboardButton("üí≥ –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ", url=payment_url)]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await message.reply_text(
                        f"üí≥ <b>–û–ø–ª–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∫–∏</b>\n\n"
                        f"‚úÖ –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã:\n"
                        f"üìß Email: {email}\n"
                        f"üí≥ –¢–∞—Ä–∏—Ñ: {tariff}\n"
                        f"üí∞ –°—É–º–º–∞: {price}‚ÇΩ\n\n"
                        f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –æ–ø–ª–∞—Ç–µ:",
                        parse_mode='HTML',
                        reply_markup=reply_markup
                    )
                    print("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π –æ–ø–ª–∞—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
                    return
                else:
                    print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∏–Ω–≤–æ–π—Å")
                    await message.reply_text("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                    return
                    
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞: {e}")
                await message.reply_text("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                return
            
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–∞: {e}")
        import traceback
        print(f"üìã Traceback: {traceback.format_exc()}")
        await message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö")

async def button(update: Update, context: CallbackContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "payment_menu":
        await payment_menu(update, context)
    elif query.data == "more_info":
        await more_info(update, context)
    elif query.data == "back_to_start":
        await start(update, context)

def main() -> None:
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    print("üöÄ –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ —Å webhook...")
    print(f"üîë TELEGRAM_BOT_TOKEN: {TELEGRAM_BOT_TOKEN[:20]}...")
    print(f"üîë LAVA_TOP_API_KEY: {'–£–°–¢–ê–ù–û–í–õ–ï–ù' if LAVA_TOP_API_KEY else '–ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù'}")
    print(f"üë• –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –ø–æ ID: {ADMIN_IDS}")
    
    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    app.telegram_app = application # –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∫ Flask
    
    print("üìù –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤...")
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è web_app_data –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–µ—Ä–≤—ã–º
    application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_web_app_data))
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("payment", payment))
    application.add_handler(CommandHandler("more_info", more_info))
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    application.add_handler(CallbackQueryHandler(button))
    application.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_all_messages))
    
    print("‚úÖ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã")
    
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Mini Apps –¥–ª—è –±–æ—Ç–∞
    try:
        print("üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Mini Apps...")
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –±–æ—Ç–∞
        commands = [
            ("start", "–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞"),
            ("payment", "–û–ø–ª–∞—Ç–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É"),
            ("more_info", "–ü–æ–¥—Ä–æ–±–Ω–µ–µ")
        ]
        
        set_commands_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setMyCommands"
        commands_data = {"commands": [{"command": cmd[0], "description": cmd[1]} for cmd in commands]}
        
        response = requests.post(set_commands_url, json=commands_data)
        if response.status_code == 200:
            print("‚úÖ –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
        else:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–º–∞–Ω–¥: {response.text}")
            
    except Exception as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ Mini Apps: {e}")
    
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º webhook URL –¥–ª—è Railway
    webhook_url = os.getenv('RAILWAY_STATIC_URL', '')
    if not webhook_url:
        webhook_url = os.getenv('PUBLIC_BASE_URL', '')
    
    # –ï—Å–ª–∏ –º—ã –≤ Railway, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π URL
    if not webhook_url and os.getenv('RAILWAY_ENVIRONMENT'):
        webhook_url = 'https://formulaprivate-productionpaymentuknow.up.railway.app'
        print(f"üåê –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Å—Ä–µ–¥–∞ Railway, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π URL: {webhook_url}")
    
    if webhook_url:
        # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ URL –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å https://
        if not webhook_url.startswith('http'):
            webhook_url = f"https://{webhook_url}"
        
        print(f"üåê –ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook: {webhook_url}/webhook")
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º webhook URL —á–µ—Ä–µ–∑ requests (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        webhook_setup_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setWebhook"
        webhook_data = {
            "url": f"{webhook_url}/webhook",
            "secret_token": os.getenv('WEBHOOK_SECRET', 'Telegram_Webhook_Secret_2024_Formula_Bot_7a6b5c')
        }
        
        try:
            # –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π webhook
            delete_webhook_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/deleteWebhook"
            delete_response = requests.post(delete_webhook_url)
            print(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ webhook: {delete_response.status_code}")
            
            # –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ
            import time
            time.sleep(2)
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π webhook —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
            webhook_data_with_params = {
                "url": f"{webhook_url}/webhook",
                "secret_token": os.getenv('WEBHOOK_SECRET', 'Telegram_Webhook_Secret_2024_Formula_Bot_7a6b5c'),
                "max_connections": 40,
                "allowed_updates": ["message", "callback_query"]
            }
            
            response = requests.post(webhook_setup_url, json=webhook_data_with_params)
            print(f"üì° –£—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook: {response.status_code}")
            if response.status_code == 200:
                print("‚úÖ Webhook —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            else:
                print(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook: {response.text}")
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook: {e}")
    else:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å webhook URL")
        print("üöÄ –ó–∞–ø—É—Å–∫–∞–µ–º Flask –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –±–µ–∑ webhook")
    
    print("üöÄ –ó–∞–ø—É—Å–∫ Flask –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...")
    # –ó–∞–ø—É—Å–∫–∞–µ–º Flask –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    port = int(os.getenv('PORT', 8080))
    app.run(host='0.0.0.0', port=port, debug=False)

if __name__ == '__main__':
    main()
